{"version":3,"sources":["src/audiochart-all.js"],"names":["exports","GoogleDataWrapper","[object Object]","data","this","numberOfDataColumns","i","getNumberOfColumns","role","getColumnRole","results","push","getColumnLabel","series","getColumnRange","min","max","index","getValue","getNumberOfRows","JSONDataWrapper","json","object","JSON","parse","Error","length","Math","apply","values","C3DataWrapper","numberOfSeries","columns","hasOwnProperty","slice","HTMLTableDataWrapper","table","getElementsByTagName","children","Array","from","cell","textContent","querySelectorAll","parseFloat","_seriesFloats","PitchMapper","seriesInfo","_minimumDatum","_maximumDatum","_minimumFrequency","_maximumFrequency","_dataRange","_frequencyRange","forEach","maximumDatum","minimumDatum","maximumFrequency","minimumFrequency","datum","FrequencyPitchMapper","super","ratio","Sounder","context","undefined","_context","_numberOfSeries","_oscillators","createOscillator","type","connect","destination","start","frequency","value","oscillator","stop","Player","duration","pitchMapper","sounder","visualCallback","arguments","seriesLen","seriesLength","numSeries","sampling","_samplingInfo","interval","sampleOneIn","in","seriesMaxIndex","_state","_play","_pause","_playLoop","String","skip","delta","playIndex","_playOne","playTimes","playCount","startTime","performance","now","intervalID","setInterval","thisPlayTimeStart","map","seriesValue","clearInterval","reduce","acc","cur","slots","idealInterval","ceil","floor","round","sample","getAudioContext","audioContext","window","AudioContext","webkitAudioContext","googleVisualCallbackMaker","chart","row","setSelection","htmlTableVisualCallbackMaker","className","rows","classList","remove","add","c3VisualCallbackMaker","select","KeyboardHandler","container","player","setAttribute","addEventListener","keypressHandler","bind","event","preventDefault","key","handleRight","handleLeft","handleSpace","stepBackward","stepForward","playPause","AudioChart","options","_setUp","_options","newOptions","Object","keys","patchedOptions","assign","_checkOptions","_wireUpStuff","freeze","assigned","_assignWrapperCallback","dataWrapper","WrapperClass","dataSource","callback","seriesMin","seriesMax","frequencyLow","frequencyHigh","frequencyPitchMapper","chartContainer","result","chartTypeToWrapperClass","google","htmlTable","c3","chartTypeToVisualCallbackMaker","highlightClass"],"mappings":"AAAA,cACA,SAAUA,SA0DHC,EACLC,YAAYC,GACXC,KAAKD,KAAOA,EAGbD,YACC,IAAIG,EAAsB,EAI1B,IAAK,IAAIC,EAAI,EAAGA,EAAIF,KAAKD,KAAKI,qBAAsBD,IAAK,CACxD,MAAME,EAAOJ,KAAKD,KAAKM,cAAcH,GACxB,KAATE,GAAwB,SAATA,IAClBH,GAAuB,GAIzB,OAAOA,EAGRH,cACC,MAAMQ,KACN,IAAK,IAAIJ,EAAI,EAAGA,EAAIF,KAAKD,KAAKI,qBAAuB,EAAGD,IACvDI,EAAQC,KAAKP,KAAKD,KAAKS,eAAeN,IAEvC,OAAOI,EAGRR,UAAUW,GACT,OAAOT,KAAKD,KAAKW,eAAeD,EAAS,GAAGE,IAG7Cb,UAAUW,GACT,OAAOT,KAAKD,KAAKW,eAAeD,EAAS,GAAGG,IAG7Cd,YAAYW,EAAQI,GACnB,OAAOb,KAAKD,KAAKe,SAASD,EAAOJ,EAAS,GAG3CX,aAAaW,GACZ,OAAOT,KAAKD,KAAKgB,yBAcbC,EACLlB,YAAYmB,GACX,GAAoB,iBAATA,EACVjB,KAAKkB,OAASC,KAAKC,MAAMH,OACnB,CAAA,GAAoB,iBAATA,EAGjB,MAAMI,MAAM,mDAFZrB,KAAKkB,OAASD,GAMhBnB,YACC,OAAOE,KAAKkB,OAAOnB,KAAKuB,OAGzBxB,cACC,MAAMQ,KACN,IAAK,IAAIJ,EAAI,EAAGA,EAAIF,KAAKkB,OAAOnB,KAAKuB,OAAQpB,IAC5CI,EAAQC,KAAKP,KAAKkB,OAAOnB,KAAKG,GAAGO,QAElC,OAAOH,EAGRR,UAAUW,GACT,OAAOc,KAAKZ,IAAIa,MAAMxB,KAAMA,KAAKkB,OAAOnB,KAAKU,GAAQgB,QAGtD3B,UAAUW,GACT,OAAOc,KAAKX,IAAIY,MAAMxB,KAAMA,KAAKkB,OAAOnB,KAAKU,GAAQgB,QAGtD3B,YAAYW,EAAQI,GACnB,OAAOb,KAAKkB,OAAOnB,KAAKU,GAAQgB,OAAOZ,GAGxCf,aAAaW,GACZ,OAAOT,KAAKkB,OAAOnB,KAAKU,GAAQgB,OAAOH,cAcnCI,EACL5B,YAAYC,GACX,GAAoB,iBAATA,EAGV,MAAMsB,MAAM,2CAFZrB,KAAKkB,OAASnB,EAMhBD,YACC,IAAI6B,EAAiB3B,KAAKkB,OAAOU,QAAQN,OAIzC,OAHItB,KAAKkB,OAAOW,eAAe,OAC9BF,GAAkB,GAEZA,EAGR7B,cACC,MAAMQ,KACN,IAAK,IAAIJ,EAAI,EAAGA,EAAIF,KAAKkB,OAAOU,QAAQN,OAAQpB,IAC/CI,EAAQC,KAAKP,KAAKkB,OAAOU,QAAQ1B,GAAG,IAErC,OAAOI,EAGRR,UAAUW,GACT,OAAOc,KAAKZ,IAAIa,MAAMxB,KAAMA,KAAKkB,OAAOU,QAAQnB,GAAQqB,MAAM,IAG/DhC,UAAUW,GACT,OAAOc,KAAKX,IAAIY,MAAMxB,KAAMA,KAAKkB,OAAOU,QAAQnB,GAAQqB,MAAM,IAG/DhC,YAAYW,EAAQI,GACnB,OAAOb,KAAKkB,OAAOU,QAAQnB,GAAQI,EAAQ,GAG5Cf,aAAaW,GACZ,OAAOT,KAAKkB,OAAOU,QAAQnB,GAAQa,OAAS,SAaxCS,EACLjC,YAAYkC,GAEX,GADAhC,KAAKgC,MAAQA,GACRhC,KAAKgC,MACT,MAAMX,MAAM,mBAIdvB,YACC,OAAOE,KAAKgC,MAAMC,qBAAqB,MAAM,GAAGC,SAASZ,OAG1DxB,cACC,OAAOqC,MAAMC,KACZpC,KAAKgC,MAAMC,qBAAqB,MAC/BI,GAASA,EAAKC,aAGjBxC,cAAcW,GACb,OAAO0B,MAAMC,KACZpC,KAAKgC,MAAMO,iCAAiC9B,EAAS,MACpD4B,GAASG,WAAWH,EAAKC,cAG5BxC,UAAUW,GACT,OAAOc,KAAKZ,IAAIa,MAAMxB,KAAMA,KAAKyC,cAAchC,IAGhDX,UAAUW,GACT,OAAOc,KAAKX,IAAIY,MAAMxB,KAAMA,KAAKyC,cAAchC,IAGhDX,YAAYW,EAAQI,GACnB,OAAO2B,WACNxC,KAAKgC,MAAMC,qBAAqB,MAAMpB,EAAQ,GAC5CqB,SAASzB,GAAQ6B,aAGrBxC,aAAaW,GACZ,OAAOT,KAAKgC,MAAMC,qBAAqB,MAAMX,OAAS,SASlDoB,EASL5C,YAAY6C,GAEX3C,KAAK4C,iBACL5C,KAAK6C,iBACL7C,KAAK8C,qBACL9C,KAAK+C,qBACL/C,KAAKgD,cACLhD,KAAKiD,mBAELN,EAAWO,QAAQ,CAACzC,EAAQI,KAC3B,GAAIJ,EAAO0C,aAAe1C,EAAO2C,aAChC,MAAM/B,MAAM,4CAGb,GAAIZ,EAAO4C,iBAAmB5C,EAAO6C,iBACpC,MAAMjC,MAAM,oDAGbrB,KAAK4C,cAAc/B,GAASJ,EAAO2C,aACnCpD,KAAK6C,cAAchC,GAASJ,EAAO0C,aACnCnD,KAAK8C,kBAAkBjC,GAASJ,EAAO6C,iBACvCtD,KAAK+C,kBAAkBlC,GAASJ,EAAO4C,iBAGvCrD,KAAKgD,WAAWnC,GACfb,KAAK6C,cAAchC,GAASb,KAAK4C,cAAc/B,GAChDb,KAAKiD,gBAAgBpC,GACpBb,KAAK+C,kBAAkBlC,GAASb,KAAK8C,kBAAkBjC,KAS1Df,IAAIyD,GACH,MAAMlC,MAAM,wCAURmC,UAA6Bd,EAUlC5C,YAAY6C,GACXc,MAAMd,GASP7C,IAAIW,EAAQ8C,GACX,IAAIG,EAOJ,OALCA,EADG1D,KAAKgD,WAAWvC,IACV8C,EAAQvD,KAAK4C,cAAcnC,IACjCT,KAAKgD,WAAWvC,GAEX,GAEFT,KAAK8C,kBAAkBrC,GAC1BiD,EAAQ1D,KAAKiD,gBAAgBxC,UAU7BkD,EACL7D,YAAY8D,EAASjC,GACpB,QAAgBkC,IAAZD,EACH,MAAMvC,MAAM,0BAIb,GAFArB,KAAK8D,SAAWF,OAEOC,IAAnBlC,EACH,MAAMN,MAAM,kCACN,GAAIM,EAAiB,EAC3B,MAAMN,MAAM,qCAEbrB,KAAK+D,gBAAkBpC,EAMxB7B,QAECE,KAAKgE,gBACL,IAAK,IAAI9D,EAAI,EAAGA,EAAIF,KAAK+D,gBAAiB7D,IACzCF,KAAKgE,aAAa9D,GAAKF,KAAK8D,SAASG,mBAC3B,IAAN/D,IAASF,KAAKgE,aAAa9D,GAAGgE,KAAO,UACzClE,KAAKgE,aAAa9D,GAAGiE,QAAQnE,KAAK8D,SAASM,aAC3CpE,KAAKgE,aAAa9D,GAAGmE,MAAM,GAS7BvE,UAAUW,EAAQ6D,GACjBtE,KAAKgE,aAAavD,GAAQ6D,UAAUC,MAAQD,EAM7CxE,OACCE,KAAKgE,aAAad,QAASsB,GAAeA,EAAWC,eAajDC,EACL5E,YAAY6E,EAAU5E,EAAM6E,EAAaC,EAASC,GACjD9E,KAAKD,KAAOA,EACZC,KAAK4E,YAAcA,EACnB5E,KAAK6E,QAAUA,EACXE,UAAUzD,OAAS,EACtBtB,KAAK8E,eAAiB,KAEtB9E,KAAK8E,eAAiBA,EAGvB,MAAME,EAAYhF,KAAKD,KAAKkF,aAAa,GAEzCjF,KAAK+D,gBAAkB/D,KAAKD,KAAKmF,YAEjC,MAAMC,EAAWT,EAAOU,cAAcT,EAAUK,GAChDhF,KAAKqF,SAAWF,EAASE,SACzBrF,KAAKsF,YAAcH,EAASI,GAE5BvF,KAAKwF,eAAiBR,EAAY,EAClChF,KAAKyF,OAAS,QAMf3F,YACC,OAAQE,KAAKyF,QACZ,IAAK,QACJzF,KAAK0F,QACL,MACD,IAAK,UACJ1F,KAAK2F,SACL,MACD,IAAK,SACJ3F,KAAK4F,YACL,MACD,IAAK,WACJ5F,KAAK0F,QACL,MACD,QACC,MAAMrE,MAAM,gCAAkCwE,OAAO7F,KAAKyF,UAI7D3F,aAAagG,GACZ,MAAMC,EAAQD,GAAQ,GACtB9F,KAAKgG,WAAaD,EACd/F,KAAKgG,UAAY,IACpBhG,KAAKgG,UAAY,GAEE,WAAhBhG,KAAKyF,QACRzF,KAAKiG,WAIPnG,YAAYgG,GACX,MAAMC,EAAQD,GAAQ,GACtB9F,KAAKgG,WAAaD,EACd/F,KAAKgG,UAAYhG,KAAKwF,iBACzBxF,KAAKgG,UAAYhG,KAAKwF,gBAEH,WAAhBxF,KAAKyF,QACRzF,KAAKiG,WASPnG,QAECE,KAAKkG,aACLlG,KAAKmG,UAAY,EAEjBnG,KAAKoG,UAAYC,YAAYC,MAC7BtG,KAAK6E,QAAQR,MAAM,GACnBrE,KAAKgG,UAAY,EAEjBhG,KAAK4F,YAON9F,YACCE,KAAKyF,OAAS,UACdzF,KAAKiG,WACLjG,KAAKuG,WAAaC,YAAY,IAAMxG,KAAKiG,WAAYjG,KAAKqF,UAQ3DvF,WACC,MAAM2G,EAAoBJ,YAAYC,MAEtC,GAAItG,KAAKgG,WAAahG,KAAKwF,eAAgB,CAEd,OAAxBxF,KAAK8E,gBACR9E,KAAK8E,eAAe9E,KAAKgG,WAE1B,IAAK,IAAI9F,EAAI,EAAGA,EAAIF,KAAK+D,gBAAiB7D,IACzCF,KAAK6E,QAAQP,UAAUpE,EAAGF,KAAK4E,YAAY8B,IAAIxG,EAC9CF,KAAKD,KAAK4G,YAAYzG,EAAGF,KAAKgG,iBAE1B,CAENY,cAAc5G,KAAKuG,YACnBvG,KAAK6E,QAAQJ,OACbzE,KAAKyF,OAAS,WAIFzF,KAAKkG,UAAUW,OAAO,CAACC,EAAKC,IAAQD,EAAMC,GACnC/G,KAAKkG,UAAU5E,OAInCtB,KAAKgG,WAAahG,KAAKsF,YAAc,EAAItF,KAAKsF,YAAc,EAC5DtF,KAAKmG,WAAa,EAClBnG,KAAKkG,UAAU3F,KAAK8F,YAAYC,MAAQG,GASzC3G,SACC8G,cAAc5G,KAAKuG,YACnBvG,KAAKyF,OAAS,SAIf3F,qBAAqB6E,EAAUK,GAE9B,IAAIK,EACAC,EACA0B,EAEJ,MAAMC,EAAgB1F,KAAK2F,KAAKvC,EAAWK,GAG3C,GAAIiC,EARgB,GAQa,CAChC5B,EATmB,GAUnB2B,EAAQzF,KAAK4F,MAAMxC,EAVA,IAYnBW,EAAc/D,KAAK6F,MAAMpC,EAAYgC,QAGrCA,EAAQzF,KAAK4F,MAAMxC,EAfA,IAgBnBU,EAAW4B,EACX3B,EAAc,EAKf,OACC+B,OAAU,EACV9B,GAAMD,EACND,SAAYA,IAWf,IAAIiC,EAAkB,WACrB,IAAIC,EAAe,KAcnB,YAZ4B1D,IAAxB2D,OAAOC,aACVF,EAAe,IAAIC,OAAOC,kBACc5D,IAA9B2D,OAAOE,qBAEjBH,EAAe,IAAIC,OAAOE,oBAI3B,WACC,OAAOH,GAZa,GAwBlBI,EAA4B,SAASC,GACxC,OAAO,SAASC,GACfD,EAAME,eAEJD,IAAOA,OAcPE,EAA+B,SAAS/F,EAAOgG,GAClD,OAAO,SAASH,GACf,MAAMI,EAAOjG,EAAMC,qBAAqB,MAExC,IAAK,MAAM4F,KAAOI,EACjBJ,EAAIK,UAAUC,OAAOH,GAGtBC,EAAKJ,EAAM,GAAGK,UAAUE,IAAIJ,KAY1BK,EAAwB,SAAST,GACpC,OAAO,SAASC,GACfD,EAAMU,OAAO,MAAOT,IAAM,WAatBU,EACLzI,YAAY0I,EAAWC,GACtB,IAAKD,EACJ,MAAMnH,MAAM,sBAEb,IAAKoH,EACJ,MAAMpH,MAAM,mBAGbmH,EAAUE,aAAa,WAAY,KACnCF,EAAUG,iBAAiB,UAAW3I,KAAK4I,gBAAgBC,KAAK7I,OAChEA,KAAKyI,OAASA,EAYf3I,gBAAgBgJ,GACfA,EAAMC,iBAEY,eAAdD,EAAME,IACThJ,KAAKiJ,cACmB,cAAdH,EAAME,IAChBhJ,KAAKkJ,aACmB,MAAdJ,EAAME,KAChBhJ,KAAKmJ,cAKPrJ,aACCE,KAAKyI,OAAOW,eAIbtJ,cACCE,KAAKyI,OAAOY,cAIbvJ,cACCE,KAAKyI,OAAOa,mBAqCRC,EAOLzJ,YAAY0J,GACX,MAAM5F,EAAU0D,IAChB,GAAgB,OAAZ1D,EACH,MAAMvC,MACL,0DAEFrB,KAAKyJ,OAAO7F,EAAS4F,GAMtB1J,YACCE,KAAKyI,OAAOa,YAObE,cACC,OAAOxJ,KAAK0J,SAUb5J,cAAc6J,GACb,QAAmB9F,IAAf8F,GAA+D,IAAnCC,OAAOC,KAAKF,GAAYrI,OACvD,MAAMD,MAAM,wBAEb,MAAMyI,EAAiBF,OAAOG,UAAW/J,KAAK0J,SAAUC,GACxD3J,KAAKyJ,OAAOnC,IAAmBwC,GAUhChK,OAAO8D,EAAS4F,GAcfD,EAAWS,cAAcR,GAIzBxJ,KAAKiK,aAAarG,EAAS4F,GAK3BxJ,KAAK0J,SAAWE,OAAOM,OAAOV,GAU/B1J,qBAAqB0J,GACpB,IAAKA,EAAQ3H,eAAe,YAC3B,MAAMR,MAAM,qBAGb,IAAKmI,EAAQ3H,eAAe,gBAC3B,MAAMR,MAAM,8BAGb,IAAKmI,EAAQ3H,eAAe,iBAC3B,MAAMR,MAAM,8BAGb,OAAQmI,EAAQtF,MACf,IAAK,SACL,IAAK,KACL,IAAK,OACJ,IAAKsF,EAAQ3H,eAAe,QAC3B,MAAMR,MAAM,qCAEb,MACD,IAAK,YACJ,IAAKmI,EAAQ3H,eAAe,SAC3B,MAAMR,MAAM,sCAEb,MACD,QACC,MAAMA,4BAA4BmI,EAAQtF,iBAc7CpE,aAAa8D,EAAS4F,GACrB,MAAMW,EAAWZ,EAAWa,uBAAuBZ,GAC7Ca,EAAc,IAAIF,EAASG,aAAaH,EAASI,YACjDC,EAAWL,EAASrF,eAEpBnD,EAAiB0I,EAAYnF,YAE7BvC,KACN,IAAK,IAAIzC,EAAI,EAAGA,EAAIyB,EAAgBzB,IACnCyC,EAAWpC,MACV6C,aAAciH,EAAYI,UAAUvK,GACpCiD,aAAckH,EAAYK,UAAUxK,GACpCoD,iBAAkBkG,EAAQmB,aAC1BtH,iBAAkBmG,EAAQoB,gBAI5B,MAAMC,EAAuB,IAAIrH,EAAqBb,GAEhDkC,EAAU,IAAIlB,EAAQC,EAASjC,GAErC3B,KAAKyI,OAAS,IAAI/D,EACjB8E,EAAQ7E,SACR0F,EACAQ,EACAhG,EACA2F,GAEGhB,EAAQsB,gBACX,IAAIvC,EACHiB,EAAQsB,eACR9K,KAAKyI,QAYR3I,8BAA8B0J,GAC7B,MAAMuB,GACLT,aAAgB,KAChBC,WAAc,KACdzF,eAAkB,MAGbkG,GACLC,OAAQpL,EACRoB,KAAMD,EACNkK,UAAWnJ,EACXoJ,GAAIzJ,GAGC0J,GACLH,OAAQtD,EACRwD,GAAI9C,GAGL,OAAQmB,EAAQtF,MACf,IAAK,SACL,IAAK,OACL,IAAK,KACJ6G,EAAOT,aAAeU,EAAwBxB,EAAQtF,MACtD6G,EAAOR,WAAaf,EAAQzJ,KACxByJ,EAAQ3H,eAAe,WAC1BkJ,EAAOjG,eACNsG,EAA+B5B,EAAQtF,MACtCsF,EAAQ5B,QAEX,MACD,IAAK,YACJmD,EAAOT,aAAevI,EACtBgJ,EAAOR,WAAaf,EAAQxH,MACxBwH,EAAQ3H,eAAe,oBAC1BkJ,EAAOjG,eAAiBiD,EACvByB,EAAQxH,MACRwH,EAAQ6B,iBAKZ,OAAON,GAITnL,EAAQ2J,WAAaA,EAv8BtB,CAw8BGvJ","sourcesContent":["'use strict';\n(function(exports) {\n\t/**\n\t * @interface DataWrapper\n\t *\n\t * The common interface that the other DataWrappers use.  This is validated\n\t * by the unit tests.\n\t *\n\t * Note: it is not done as a superclass (as {@link PitchMapper} is) because\n\t *       there's really nothing in common implementation-wise; only the\n\t *       interface is shared.\n\t *\n\t * @private\n\t */\n\t/**\n\t * Returns the number of series in the underlying data\n\t * @function DataWrapper#numSeries\n\t * @returns {integer} The number of series\n\t */\n\t/**\n\t * Get a list of the underlying data series names\n\t * @function DataWrapper#seriesNames\n\t * @returns {string[]} An array of the series names\n\t */\n\t/**\n\t * What is the minimum value in a given series?\n\t * @function DataWrapper#seriesMin\n\t * @param {index} series - The series number\n\t * @returns {Number} The minimum value in the series\n\t */\n\t/**\n\t * What is the maximum value in a given series?\n\t * @function DataWrapper#seriesMax\n\t * @param {index} series - The series number\n\t * @returns {Number} The maximum value in the series\n\t */\n\t/**\n\t * Get value of specific datum\n\t * @function DataWrapper#seriesValue\n\t * @param {index} series - The series number\n\t * @param {index} index - The row number\n\t * @todo rename `index` to `row`?\n\t * @returns {Number} the datum\n\t */\n\t/**\n\t * What is the length of a series?\n\t * @function DataWrapper#seriesLength\n\t * @param {index} series - The series\n\t * @returns {integer} The number of data in the series\n\t */\n\n\n\t/**\n\t * This interfaces to Google's {@link https://developers.google.com/chart/interactive/docs/reference#DataTable|DataTable} class.\n\t *\n\t * @private\n\t * @implements {DataWrapper}\n\t * @param {GoogleDataTable} data - The in-memory GoogleDataTable\n\t */\n\tclass GoogleDataWrapper {\n\t\tconstructor(data) {\n\t\t\tthis.data = data\n\t\t}\n\n\t\tnumSeries() {\n\t\t\tlet numberOfDataColumns = 0\n\n\t\t\t// Check the role of each column\n\t\t\t// Note: the first, domain, column, isn't counted\n\t\t\tfor (let i = 1; i < this.data.getNumberOfColumns(); i++) {\n\t\t\t\tconst role = this.data.getColumnRole(i)\n\t\t\t\tif (role === '' || role === 'data') {  // TODO 'data' used?\n\t\t\t\t\tnumberOfDataColumns += 1\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn numberOfDataColumns\n\t\t}\n\n\t\tseriesNames() {\n\t\t\tconst results = []\n\t\t\tfor (let i = 0; i < this.data.getNumberOfColumns() - 1; i++) {\n\t\t\t\tresults.push(this.data.getColumnLabel(i))\n\t\t\t}\n\t\t\treturn results\n\t\t}\n\n\t\tseriesMin(series) {\n\t\t\treturn this.data.getColumnRange(series + 1).min\n\t\t}\n\n\t\tseriesMax(series) {\n\t\t\treturn this.data.getColumnRange(series + 1).max\n\t\t}\n\n\t\tseriesValue(series, index) {\n\t\t\treturn this.data.getValue(index, series + 1)\n\t\t}\n\n\t\tseriesLength(series) {\n\t\t\treturn this.data.getNumberOfRows()\n\t\t}\n\t}\n\n\n\t/**\n\t * This allows a JSON fragment to be used as a data source.\n\t *\n\t * @todo document format\n\t *\n\t * @private\n\t * @implements {DataWrapper}\n\t * @param {JSON} json - The JSON data, as a string or object\n\t */\n\tclass JSONDataWrapper {\n\t\tconstructor(json) {\n\t\t\tif (typeof json === 'string') {\n\t\t\t\tthis.object = JSON.parse(json)\n\t\t\t} else if (typeof json === 'object') {\n\t\t\t\tthis.object = json\n\t\t\t} else {\n\t\t\t\tthrow Error('Please provide a JSON string or derived object.')\n\t\t\t}\n\t\t}\n\n\t\tnumSeries() {\n\t\t\treturn this.object.data.length\n\t\t}\n\n\t\tseriesNames() {\n\t\t\tconst results = []\n\t\t\tfor (let i = 0; i < this.object.data.length; i++) {\n\t\t\t\tresults.push(this.object.data[i].series)\n\t\t\t}\n\t\t\treturn results\n\t\t}\n\n\t\tseriesMin(series) {\n\t\t\treturn Math.min.apply(this, this.object.data[series].values)\n\t\t}\n\n\t\tseriesMax(series) {\n\t\t\treturn Math.max.apply(this, this.object.data[series].values)\n\t\t}\n\n\t\tseriesValue(series, index) {\n\t\t\treturn this.object.data[series].values[index]\n\t\t}\n\n\t\tseriesLength(series) {\n\t\t\treturn this.object.data[series].values.length\n\t\t}\n\t}\n\n\n\t/**\n\t * Support C3-format data objects\n\t *\n\t * @todo document format\n\t *\n\t * @private\n\t * @implements {DataWrapper}\n\t * @param {Object} data - The C3-format data object\n\t */\n\tclass C3DataWrapper {\n\t\tconstructor(data) {\n\t\t\tif (typeof data === 'object') {\n\t\t\t\tthis.object = data\n\t\t\t} else {\n\t\t\t\tthrow Error('Please provide a C3-format data object.')\n\t\t\t}\n\t\t}\n\n\t\tnumSeries() {\n\t\t\tlet numberOfSeries = this.object.columns.length\n\t\t\tif (this.object.hasOwnProperty('x')) {\n\t\t\t\tnumberOfSeries -= 1\n\t\t\t}\n\t\t\treturn numberOfSeries\n\t\t}\n\n\t\tseriesNames() {\n\t\t\tconst results = []\n\t\t\tfor (let i = 0; i < this.object.columns.length; i++) {\n\t\t\t\tresults.push(this.object.columns[i][0])\n\t\t\t}\n\t\t\treturn results\n\t\t}\n\n\t\tseriesMin(series) {\n\t\t\treturn Math.min.apply(this, this.object.columns[series].slice(1))\n\t\t}\n\n\t\tseriesMax(series) {\n\t\t\treturn Math.max.apply(this, this.object.columns[series].slice(1))\n\t\t}\n\n\t\tseriesValue(series, index) {\n\t\t\treturn this.object.columns[series][index + 1]\n\t\t}\n\n\t\tseriesLength(series) {\n\t\t\treturn this.object.columns[series].length - 1\n\t\t}\n\t}\n\n\n\t/**\n\t * Allows an HTML table to be used as a data source.\n\t *\n\t * @private\n\t * @implements {DataWrapper}\n\t * @param {HTMLTableElement} table - The in-DOM table element\n\t * @todo check it's a table\n\t */\n\tclass HTMLTableDataWrapper {\n\t\tconstructor(table) {\n\t\t\tthis.table = table\n\t\t\tif (!this.table) {\n\t\t\t\tthrow Error('No table given.')\n\t\t\t}\n\t\t}\n\n\t\tnumSeries() {\n\t\t\treturn this.table.getElementsByTagName('tr')[0].children.length\n\t\t}\n\n\t\tseriesNames() {\n\t\t\treturn Array.from(\n\t\t\t\tthis.table.getElementsByTagName('th'),\n\t\t\t\t(cell) => cell.textContent)\n\t\t}\n\n\t\t_seriesFloats(series) {\n\t\t\treturn Array.from(\n\t\t\t\tthis.table.querySelectorAll(`td:nth-child(${series + 1})`),\n\t\t\t\t(cell) => parseFloat(cell.textContent))\n\t\t}\n\n\t\tseriesMin(series) {\n\t\t\treturn Math.min.apply(this, this._seriesFloats(series))\n\t\t}\n\n\t\tseriesMax(series) {\n\t\t\treturn Math.max.apply(this, this._seriesFloats(series))\n\t\t}\n\n\t\tseriesValue(series, index) {\n\t\t\treturn parseFloat(\n\t\t\t\tthis.table.getElementsByTagName('tr')[index + 1]\n\t\t\t\t\t.children[series].textContent)\n\t\t}\n\n\t\tseriesLength(series) {\n\t\t\treturn this.table.getElementsByTagName('tr').length - 1\n\t\t}\n\t}\n\n\t/**\n\t * Base Pitch Mapper\n\t * @private\n\t * @abstract\n\t */\n\tclass PitchMapper {\n\t\t/**\n\t\t * Create a base Pitch Mapper\n\t\t * @param {Object[]} seriesInfo - min and max data and frequencies\n\t\t * @param {string} seriesInfo[].minimumDatum - minimun data value\n\t\t * @param {string} seriesInfo[].maximumDatum - maximun data value\n\t\t * @param {string} seriesInfo[].minimumFrequency - minimun frequency\n\t\t * @param {string} seriesInfo[].maximumFrequency - maximun frequency\n\t\t */\n\t\tconstructor(seriesInfo) {\n\t\t\t// Store the info for all series\n\t\t\tthis._minimumDatum = []\n\t\t\tthis._maximumDatum = []\n\t\t\tthis._minimumFrequency = []\n\t\t\tthis._maximumFrequency = []\n\t\t\tthis._dataRange = []\n\t\t\tthis._frequencyRange = []\n\n\t\t\tseriesInfo.forEach((series, index) => {\n\t\t\t\tif (series.maximumDatum < series.minimumDatum) {\n\t\t\t\t\tthrow Error('minimum datum should be <= maximum datum')\n\t\t\t\t}\n\n\t\t\t\tif (series.maximumFrequency < series.minimumFrequency) {\n\t\t\t\t\tthrow Error('minimum frequency should be <= maximum frequency')\n\t\t\t\t}\n\n\t\t\t\tthis._minimumDatum[index] = series.minimumDatum\n\t\t\t\tthis._maximumDatum[index] = series.maximumDatum\n\t\t\t\tthis._minimumFrequency[index] = series.minimumFrequency\n\t\t\t\tthis._maximumFrequency[index] = series.maximumFrequency\n\n\t\t\t\t// Pre-calculate for performance (I expect) when mapping\n\t\t\t\tthis._dataRange[index] =\n\t\t\t\t\tthis._maximumDatum[index] - this._minimumDatum[index]\n\t\t\t\tthis._frequencyRange[index] =\n\t\t\t\t\tthis._maximumFrequency[index] - this._minimumFrequency[index]\n\t\t\t})\n\t\t}\n\n\t\t/**\n\t\t * Map a datum to an output value\n\t\t * @param {number} datum - the datum to be mapped\n\t\t * @abstract\n\t\t */\n\t\tmap(datum) {\n\t\t\tthrow Error('Base map() must be overriden.')\n\t\t}\n\t}\n\n\n\t/**\n\t * Maps each datum to a corresponding frequency.\n\t * @private\n\t * @extends {PitchMapper}\n\t */\n\tclass FrequencyPitchMapper extends PitchMapper {\n\t\t// TODO: dupe docs for now: https://github.com/jsdoc3/jsdoc/issues/1012\n\t\t/**\n\t\t * Create a Frequency Pitch Mapper\n\t\t * @param {Object[]} seriesInfo - minimum and maximums for each series\n\t\t * @param {string} seriesInfo[].minimumDatum - minimun data value\n\t\t * @param {string} seriesInfo[].maximumDatum - maximun data value\n\t\t * @param {string} seriesInfo[].minimumFrequency - minimun frequency\n\t\t * @param {string} seriesInfo[].maximumFrequency - maximun frequency\n\t\t */\n\t\tconstructor(seriesInfo) {\n\t\t\tsuper(seriesInfo)\n\t\t}\n\n\t\t/**\n\t\t * Given a datum value, compute the corresponding frequency\n\t\t * @param {number} series - map on which series?\n\t\t * @param {number} datum - the datum to be mapped\n\t\t * @returns {number} frequency for this datum\n\t\t */\n\t\tmap(series, datum) {\n\t\t\tlet ratio\n\t\t\tif (this._dataRange[series]) {\n\t\t\t\tratio = (datum - this._minimumDatum[series])\n\t\t\t\t\t/ this._dataRange[series]\n\t\t\t} else {\n\t\t\t\tratio = 0.5\n\t\t\t}\n\t\t\treturn this._minimumFrequency[series]\n\t\t\t\t+ (ratio * this._frequencyRange[series])\n\t\t}\n\t}\n\n\t/**\n\t * Outputs sound using the Web Audio API\n\t * @private\n\t * @param {AudioContext} context - the Web Audio API context\n\t * @param {number} numberOfSeries - number of data series\n\t */\n\tclass Sounder {\n\t\tconstructor(context, numberOfSeries) {\n\t\t\tif (context === undefined) {\n\t\t\t\tthrow Error('No audio context given')\n\t\t\t}\n\t\t\tthis._context = context\n\n\t\t\tif (numberOfSeries === undefined) {\n\t\t\t\tthrow Error('No number of data series given')\n\t\t\t} else if (numberOfSeries > 2) {\n\t\t\t\tthrow Error('Large number of data series given')\n\t\t\t}\n\t\t\tthis._numberOfSeries = numberOfSeries\n\t\t}\n\n\t\t/**\n\t\t * Start the oscillator(s)\n\t\t */\n\t\tstart() {\n\t\t\t// Oscillators cannot be re-used\n\t\t\tthis._oscillators = []\n\t\t\tfor (let i = 0; i < this._numberOfSeries; i++) {\n\t\t\t\tthis._oscillators[i] = this._context.createOscillator()\n\t\t\t\tif (i === 1) this._oscillators[i].type = 'square'\n\t\t\t\tthis._oscillators[i].connect(this._context.destination)\n\t\t\t\tthis._oscillators[i].start(0)\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Set the frequency of the oscillator for a given series\n\t\t * @param {number} series - set frequency for which series?\n\t\t * @param {number} frequency - the frequency to change to (Hz)\n\t\t */\n\t\tfrequency(series, frequency) {\n\t\t\tthis._oscillators[series].frequency.value = frequency\n\t\t}\n\n\t\t/**\n\t\t * Stop the oscillator(s)\n\t\t */\n\t\tstop() {\n\t\t\tthis._oscillators.forEach((oscillator) => oscillator.stop())\n\t\t}\n\t}\n\n\t/**\n\t * Orchestrates the audible (and visual cursor) rendering of the chart\n\t * @private\n\t * @param {integer} duration - the length of the rendering in milliseconds\n\t * @param {DataWrapper} data - the underlying data (wrapped in interface)\n\t * @param {PitchMapper} pitchMapper - maps data to pitches\n\t * @param {Sounder} sounder - the sounder object\n\t * @param {VisualCallback} visualCallback - the callback function that highlights the current datum\n\t */\n\tclass Player {\n\t\tconstructor(duration, data, pitchMapper, sounder, visualCallback) {\n\t\t\tthis.data = data\n\t\t\tthis.pitchMapper = pitchMapper\n\t\t\tthis.sounder = sounder\n\t\t\tif (arguments.length < 5) {\n\t\t\t\tthis.visualCallback = null\n\t\t\t} else {\n\t\t\t\tthis.visualCallback = visualCallback\n\t\t\t}\n\n\t\t\tconst seriesLen = this.data.seriesLength(0)\n\n\t\t\tthis._numberOfSeries = this.data.numSeries()\n\n\t\t\tconst sampling = Player._samplingInfo(duration, seriesLen)\n\t\t\tthis.interval = sampling.interval\n\t\t\tthis.sampleOneIn = sampling.in\n\n\t\t\tthis.seriesMaxIndex = seriesLen - 1  // TODO just use seriesLen?\n\t\t\tthis._state = 'ready'\n\t\t}\n\n\t\t/**\n\t\t * Main entry point; manages state.\n\t\t */\n\t\tplayPause() {\n\t\t\tswitch (this._state) {\n\t\t\t\tcase 'ready':\n\t\t\t\t\tthis._play()\n\t\t\t\t\tbreak\n\t\t\t\tcase 'playing':\n\t\t\t\t\tthis._pause()\n\t\t\t\t\tbreak\n\t\t\t\tcase 'paused':\n\t\t\t\t\tthis._playLoop()\n\t\t\t\t\tbreak\n\t\t\t\tcase 'finished':\n\t\t\t\t\tthis._play()\n\t\t\t\t\tbreak\n\t\t\t\tdefault:\n\t\t\t\t\tthrow Error('Player error: invalid state: ' + String(this._state))\n\t\t\t}\n\t\t}\n\n\t\tstepBackward(skip) {\n\t\t\tconst delta = skip || 50\n\t\t\tthis.playIndex -= delta\n\t\t\tif (this.playIndex < 0) {\n\t\t\t\tthis.playIndex = 0  // TODO test limiting\n\t\t\t}\n\t\t\tif (this._state === 'paused') {\n\t\t\t\tthis._playOne()\n\t\t\t}\n\t\t}\n\n\t\tstepForward(skip) {\n\t\t\tconst delta = skip || 50\n\t\t\tthis.playIndex += delta\n\t\t\tif (this.playIndex > this.seriesMaxIndex) {\n\t\t\t\tthis.playIndex = this.seriesMaxIndex  // TODO test limiting\n\t\t\t}\n\t\t\tif (this._state === 'paused') {\n\t\t\t\tthis._playOne()\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Resets play state and sets up a recurring function to update the sound\n\t\t * (and, optionally, visual callback) at an interval dependant on the\n\t\t * number of data.\n\t\t */\n\t\t_play() {\n\t\t\t// Debugging info\n\t\t\tthis.playTimes = []  // store all lengths of time that playOne took\n\t\t\tthis.playCount = 0   // how many datum points were actually sounded?\n\n\t\t\tthis.startTime = performance.now()\n\t\t\tthis.sounder.start(0)\n\t\t\tthis.playIndex = 0\n\n\t\t\tthis._playLoop()\n\t\t}\n\n\t\t/**\n\t\t * Update state and set _playOne() to run regularly, to render the sound\n\t\t * (and optional visual cursor movement).\n\t\t */\n\t\t_playLoop() {\n\t\t\tthis._state = 'playing'\n\t\t\tthis._playOne()  // so that it starts immediately\n\t\t\tthis.intervalID = setInterval(() => this._playOne(), this.interval)\n\t\t}\n\n\t\t/**\n\t\t * This is where the sound is actually played.  If a visual callback was\n\t\t * specified, this also coordinates the visual highlighting of the current\n\t\t * datum as the playback occurs.\n\t\t */\n\t\t_playOne() {\n\t\t\tconst thisPlayTimeStart = performance.now()\n\n\t\t\tif (this.playIndex <= this.seriesMaxIndex) {\n\t\t\t\t// Play back one datum point\n\t\t\t\tif (this.visualCallback !== null) {\n\t\t\t\t\tthis.visualCallback(this.playIndex)\n\t\t\t\t}\n\t\t\t\tfor (let i = 0; i < this._numberOfSeries; i++ ) {\n\t\t\t\t\tthis.sounder.frequency(i, this.pitchMapper.map(i,\n\t\t\t\t\t\tthis.data.seriesValue(i, this.playIndex)))\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Playback is complete; clean up\n\t\t\t\tclearInterval(this.intervalID)\n\t\t\t\tthis.sounder.stop()\n\t\t\t\tthis._state = 'finished'\n\n\t\t\t\t// Debugging info\n\t\t\t\t// console.log(`Player: Playing ${this.playCount} of ${this.playIndex} took ${Math.round(performance.now() - this.startTime)} ms`)\n\t\t\t\tconst sum = this.playTimes.reduce((acc, cur) => acc + cur)\n\t\t\t\tconst mean = sum / this.playTimes.length\n\t\t\t\t// console.log(`Player: Average play func time: ${mean.toFixed(2)} ms`)\n\t\t\t}\n\n\t\t\tthis.playIndex += this.sampleOneIn > 0 ? this.sampleOneIn : 1  // TODO sl\n\t\t\tthis.playCount += 1\n\t\t\tthis.playTimes.push(performance.now() - thisPlayTimeStart)\n\t\t}\n\n\t\t/**\n\t\t * Temporarily pause the rendering of the chart.\n\t\t * This inherently keeps the sound going at the frequency it was at when\n\t\t * the pause was triggered.\n\t\t * @todo feature/object to stop/fade the sound after n seconds?\n\t\t */\n\t\t_pause() {\n\t\t\tclearInterval(this.intervalID)\n\t\t\tthis._state = 'paused'\n\t\t}\n\n\t\t/* Work out sampling rate */\n\t\tstatic _samplingInfo(duration, seriesLen) {\n\t\t\tconst minInterval = 10\n\t\t\tlet interval\n\t\t\tlet sampleOneIn\n\t\t\tlet slots\n\n\t\t\tconst idealInterval = Math.ceil(duration / seriesLen)\n\t\t\t// console.log(`sampleInfo: duration: ${duration}; series length: ${seriesLen}; ideal interval: ${idealInterval}`)\n\n\t\t\tif (idealInterval < minInterval) {\n\t\t\t\tinterval = minInterval\n\t\t\t\tslots = Math.floor(duration / minInterval)\n\t\t\t\tconst sampleOneInFloat = seriesLen / slots\n\t\t\t\tsampleOneIn = Math.round(seriesLen / slots)\n\t\t\t\t// console.log(`sampleInfo: Need to sample 1 in ${sampleOneIn} (${sampleOneInFloat})`)\n\t\t\t} else {\n\t\t\t\tslots = Math.floor(duration / minInterval)\n\t\t\t\tinterval = idealInterval\n\t\t\t\tsampleOneIn = 1\n\t\t\t}\n\n\t\t\t// console.log(`sampleInfo: it will take ${ (seriesLen / sampleOneIn) * interval}`)\n\n\t\t\treturn {\n\t\t\t\t'sample': 1,\n\t\t\t\t'in': sampleOneIn,\n\t\t\t\t'interval': interval\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Ensures that there is only one Web Audio context per page.\n\t * Sets up a new AudioContext the first time it's called; then re-uses it.\n\t * @private\n\t * @returns {AudioContext} page-global Web Audio context\n\t */\n\tvar getAudioContext = (function() {\n\t\tlet audioContext = null\n\n\t\tif (window.AudioContext !== undefined) {\n\t\t\taudioContext = new window.AudioContext()\n\t\t} else if (window.webkitAudioContext !== undefined) {\n\t\t\t/* eslint-disable new-cap */\n\t\t\taudioContext = new window.webkitAudioContext()\n\t\t\t/* eslint-enable new-cap */\n\t\t}\n\n\t\tfunction _getAudioContext() {\n\t\t\treturn audioContext\n\t\t}\n\n\t\treturn _getAudioContext\n\t})()\n\n\t/**\n\t * Generates a function that moves the cursor on a Google Chart\n\t * @private\n\t * @param {GoogleChart} chart - the in-memory GoogleChart object\n\t * @returns {VisualCallback} the callback\n\t */\n\tvar googleVisualCallbackMaker = function(chart) {\n\t\treturn function(row) {\n\t\t\tchart.setSelection([\n\t\t\t\t{\n\t\t\t\t\t'row': row\n\t\t\t\t}\n\t\t\t])\n\t\t}\n\t}\n\n\n\t/**\n\t * Generate a function that can be used to highlight table cells\n\t * @private\n\t * @param {HTMLTableElement} table - The in-DOM table element\n\t * @param {string} className - Name of the CSS highlight class\n\t * @returns {VisualCallback} The highlighting function\n\t */\n\tvar htmlTableVisualCallbackMaker = function(table, className) {\n\t\treturn function(row) {\n\t\t\tconst rows = table.getElementsByTagName('tr')\n\n\t\t\tfor (const row of rows) {\n\t\t\t\trow.classList.remove(className)\n\t\t\t}\n\n\t\t\trows[row + 1].classList.add(className)\n\t\t}\n\t}\n\n\n\t/**\n\t * Generates a function that moves the cursor on a C3 Chart\n\t * @private\n\t * @param {Object} chart - the in-memory C3 chart object\n\t * @returns {VisualCallback} the callback\n\t * @todo define C3 chart type?\n\t */\n\tvar c3VisualCallbackMaker = function(chart) {\n\t\treturn function(row) {\n\t\t\tchart.select(null, [row], true)\n\t\t}\n\t}\n\n\t/**\n\t * Set up a keyboard event listener to detect chart navigation keypresses.\n\t * @private\n\t * @param {HTMLElement} container\n\t *\t- The element (usually a <code>&lt;div&gt;</code>) containing the chart\n\t * @param {Player} player - AudioChart Player object\n\t * @todo mark up the DIV properly\n\t * @todo check what sort of element we get given? no; could be button?\n\t */\n\tclass KeyboardHandler {\n\t\tconstructor(container, player) {\n\t\t\tif (!container) {\n\t\t\t\tthrow Error('No container given')\n\t\t\t}\n\t\t\tif (!player) {\n\t\t\t\tthrow Error('No Player given')\n\t\t\t}\n\n\t\t\tcontainer.setAttribute('tabindex', '0')\n\t\t\tcontainer.addEventListener('keydown', this.keypressHandler.bind(this))\n\t\t\tthis.player = player\n\t\t}\n\n\t\t/**\n\t\t * Handle keypresses\n\t\t *\n\t\t * Note: This is bound to the {@link KeyboardHandler} so that it can call\n\t\t *       the right handler methods.\n\t\t *\n\t\t * @param {KeyboardEvent} event - the KeyboardEvent that occured\n\t\t * @todo make link work\n\t\t */\n\t\tkeypressHandler(event) {\n\t\t\tevent.preventDefault()  // TODO should this be here or later? check for defaultPrevented?\n\n\t\t\tif (event.key === 'ArrowRight') {\n\t\t\t\tthis.handleRight()\n\t\t\t} else if (event.key === 'ArrowLeft' ) {\n\t\t\t\tthis.handleLeft()\n\t\t\t} else if (event.key === ' ') {\n\t\t\t\tthis.handleSpace()\n\t\t\t}\n\t\t}\n\n\t\t/** Handle a left arrow being pressed */\n\t\thandleLeft() {\n\t\t\tthis.player.stepBackward()\n\t\t}\n\n\t\t/** Handle a right arrow being pressed */\n\t\thandleRight() {\n\t\t\tthis.player.stepForward()\n\t\t}\n\n\t\t/** Handle the space key being pressed */\n\t\thandleSpace() {\n\t\t\tthis.player.playPause()\n\t\t}\n\t}\n\n\t/** @module */\n\t/* exported AudioChart */\n\t/* global getAudioContext FrequencyPitchMapper Sounder Player KeyboardHandler GoogleDataWrapper googleVisualCallbackMaker JSONDataWrapper HTMLTableDataWrapper htmlTableVisualCallbackMaker C3DataWrapper c3VisualCallbackMaker */\n\n\t/**\n\t * Array index number (starts at zero).\n\t * Used to specify series and row in visual callbacks.\n\t * @typedef {integer} index\n\t */\n\n\n\t/**\n\t * A function that highlights the current datum, in all series, visually.\n\t * Different callbacks must be created for different types of chart.\n\t * @callback VisualCallback\n\t * @param {index} row - The row of the cell to highlight\n\t */\n\n\t/**\n\t * @typedef {Object} AudioChartOptions\n\t * @todo move the documentation here? (Downside is that the branching/groups\n\t *       of different options required for different chart types would be less\n\t *       clear.)\n\t */\n\n\t/**\n\t * @typedef {Object} WrapperAndCallbackResults\n\t * @property {Class} WrapperClass - the data wrapper class\n\t * @property {Object|HTMLTableElement} dataSource - the data source to wrap\n\t * @property {VisualCallback} visualCallback - created if requested by the user\n\t */\n\n\t/** Main object for API consumers */\n\tclass AudioChart {\n\t\t/**\n\t\t * Create an AudioChart object.\n\t\t * This first checks to see if the Web Audio API is available, and throws\n\t\t * an {Error} if not. Then check the options given by the user.\n\t\t * @param {AudioChartOptions} options - AudioChart options\n\t\t */\n\t\tconstructor(options) {\n\t\t\tconst context = getAudioContext()\n\t\t\tif (context === null) {\n\t\t\t\tthrow Error(\n\t\t\t\t\t\"Sorry, your browser doesn't support the Web Audio API.\")\n\t\t\t}\n\t\t\tthis._setUp(context, options)\n\t\t}\n\n\t\t/**\n\t\t * Passes through play/pause commands to the Player\n\t\t */\n\t\tplayPause() {\n\t\t\tthis.player.playPause()\n\t\t}\n\n\t\t/**\n\t\t * Returns the current set of options (passed in at object creation, or\n\t\t * computed when options were updated).\n\t\t */\n\t\tget options() {\n\t\t\treturn this._options\n\t\t}\n\n\t\t/**\n\t\t * Updates an AudioChart object to reflect new options. Can accept a subset\n\t\t * of the standard options, so if only, for example, duration changes, then\n\t\t * you need only specify the new duration and not the type and other\n\t\t * paramaters.\n\t\t * @param {AudioChartOptions} newOptions - Partial/full AudioChart options\n\t\t */\n\t\tupdateOptions(newOptions) {\n\t\t\tif (newOptions === undefined || Object.keys(newOptions).length === 0) {\n\t\t\t\tthrow Error('No new options given')\n\t\t\t}\n\t\t\tconst patchedOptions = Object.assign({}, this._options, newOptions)\n\t\t\tthis._setUp(getAudioContext(), patchedOptions)\n\t\t}\n\n\t\t/**\n\t\t * Checks options (either when a new AudioChart object is created, or when\n\t\t * the user has asked for them to be updated) and then set everything up.\n\t\t * @param {AudioContext} context - the Web Audio context\n\t\t * @param {AudioChartOptions} options - AudioChart options\n\t\t * @private\n\t\t */\n\t\t_setUp(context, options) {\n\t\t\t// The testing for this next bit is a bit of a fudge as curerntly I've\n\t\t\t// not come up with a beter way than having the testing done on static\n\t\t\t// functions and checking that they've been called with appropraite\n\t\t\t// values, return appropriate values, or if they throw an exception.\n\t\t\t//\n\t\t\t// The thing blocking this is that I don't know how to stub out global\n\t\t\t// ES6 classes/functions *or* how to run each test via Karma in an\n\t\t\t// isolated environment where I can mock those global classes.\n\t\t\t//\n\t\t\t// TODO, as per https://github.com/matatk/audiochart/issues/37\n\n\t\t\t// Testing this separately allows us to check the options-checking code\n\t\t\t// without having to pass in functioning source data objects.\n\t\t\tAudioChart._checkOptions(options)\n\n\t\t\t// This is not currently tested; to mitigate, it doesn't make decisions.\n\t\t\t// Actually, it does call _assignWrapperCallback() but that /is/ tested.\n\t\t\tthis._wireUpStuff(context, options)\n\n\t\t\t// Re _assignWrapperCallback(): that is also tested separately to avoid\n\t\t\t// the need for very detailed mocks for the data sources.\n\n\t\t\tthis._options = Object.freeze(options)\n\t\t}\n\n\t\t/**\n\t\t * Checks the passed-in options opbject for validity. This does not perform\n\t\t * detailed checks that are covered in the various components' constructors;\n\t\t * they run such checks themselves.\n\t\t * @param {AudioChartOptions} options - AudioChart options\n\t\t * @private\n\t\t */\n\t\tstatic _checkOptions(options) {\n\t\t\tif (!options.hasOwnProperty('duration')) {\n\t\t\t\tthrow Error('No duration given')\n\t\t\t}\n\n\t\t\tif (!options.hasOwnProperty('frequencyLow')) {\n\t\t\t\tthrow Error('No minimum frequency given')\n\t\t\t}\n\n\t\t\tif (!options.hasOwnProperty('frequencyHigh')) {\n\t\t\t\tthrow Error('No maximum frequency given')\n\t\t\t}\n\n\t\t\tswitch (options.type) {\n\t\t\t\tcase 'google':\n\t\t\t\tcase 'c3':\n\t\t\t\tcase 'json':\n\t\t\t\t\tif (!options.hasOwnProperty('data')) {\n\t\t\t\t\t\tthrow Error(\"Options must include a 'data' key\")\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\tcase 'htmlTable':\n\t\t\t\t\tif (!options.hasOwnProperty('table')) {\n\t\t\t\t\t\tthrow Error(\"Options must include a 'table' key\")\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\tdefault:\n\t\t\t\t\tthrow Error(`Invalid data type '${options.type}' given.`)\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Make a data wrapper of the appropriate class, instantiated with the\n\t\t * appropriate data paramater (from options.data) and, optionally, make\n\t\t * a visual callback (which may use options.chart, or other options if\n\t\t * it's an HTML table visual callback).\n\t\t * FIXME: Test somehow\n\t\t * @private\n\t\t * @param {AudioContext} context - the Web Audio context\n\t\t * @param {AudioChartOptions} options - given by the user\n\t\t */\n\t\t_wireUpStuff(context, options) {\n\t\t\tconst assigned = AudioChart._assignWrapperCallback(options)\n\t\t\tconst dataWrapper = new assigned.WrapperClass(assigned.dataSource)\n\t\t\tconst callback = assigned.visualCallback\n\n\t\t\tconst numberOfSeries = dataWrapper.numSeries()\n\n\t\t\tconst seriesInfo = []\n\t\t\tfor (let i = 0; i < numberOfSeries; i++ ) {\n\t\t\t\tseriesInfo.push({\n\t\t\t\t\tminimumDatum: dataWrapper.seriesMin(i),\n\t\t\t\t\tmaximumDatum: dataWrapper.seriesMax(i),\n\t\t\t\t\tminimumFrequency: options.frequencyLow,\n\t\t\t\t\tmaximumFrequency: options.frequencyHigh\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tconst frequencyPitchMapper = new FrequencyPitchMapper(seriesInfo)\n\n\t\t\tconst sounder = new Sounder(context, numberOfSeries)\n\n\t\t\tthis.player = new Player(\n\t\t\t\toptions.duration,\n\t\t\t\tdataWrapper,\n\t\t\t\tfrequencyPitchMapper,\n\t\t\t\tsounder,\n\t\t\t\tcallback)\n\n\t\t\tif (options.chartContainer) {\n\t\t\t\tnew KeyboardHandler(\n\t\t\t\t\toptions.chartContainer,\n\t\t\t\t\tthis.player)\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Works out which data source wrapper and visual callback (if requested)\n\t\t * should be used with this chart.\n\t\t * @param {AudioChartOptions} options - given by the user\n\t\t * @returns {WrapperAndCallbackResults}\n\t\t *\t- data wrapper, data source and callback (if applicable) for this chart\n\t\t * @private\n\t\t */\n\t\tstatic _assignWrapperCallback(options) {\n\t\t\tconst result = {\n\t\t\t\t'WrapperClass': null,\n\t\t\t\t'dataSource': null,\n\t\t\t\t'visualCallback': null\n\t\t\t}\n\n\t\t\tconst chartTypeToWrapperClass = {\n\t\t\t\tgoogle: GoogleDataWrapper,\n\t\t\t\tjson: JSONDataWrapper,\n\t\t\t\thtmlTable: HTMLTableDataWrapper,\n\t\t\t\tc3: C3DataWrapper\n\t\t\t}\n\n\t\t\tconst chartTypeToVisualCallbackMaker = {\n\t\t\t\tgoogle: googleVisualCallbackMaker,\n\t\t\t\tc3: c3VisualCallbackMaker\n\t\t\t}\n\n\t\t\tswitch (options.type) {\n\t\t\t\tcase 'google':\n\t\t\t\tcase 'json':\n\t\t\t\tcase 'c3':\n\t\t\t\t\tresult.WrapperClass = chartTypeToWrapperClass[options.type]\n\t\t\t\t\tresult.dataSource = options.data\n\t\t\t\t\tif (options.hasOwnProperty('chart')) {\n\t\t\t\t\t\tresult.visualCallback =\n\t\t\t\t\t\t\tchartTypeToVisualCallbackMaker[options.type](\n\t\t\t\t\t\t\t\toptions.chart)\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\tcase 'htmlTable':\n\t\t\t\t\tresult.WrapperClass = HTMLTableDataWrapper\n\t\t\t\t\tresult.dataSource = options.table\n\t\t\t\t\tif (options.hasOwnProperty('highlightClass')) {\n\t\t\t\t\t\tresult.visualCallback = htmlTableVisualCallbackMaker(\n\t\t\t\t\t\t\toptions.table,\n\t\t\t\t\t\t\toptions.highlightClass)\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t}\n\n\t\t\treturn result\n\t\t}\n\t}\n\n\texports.AudioChart = AudioChart\n})(this)\n"]}