{"version":3,"sources":["src/AudioChart.js","src/DataWrappers.js","src/KeyboardHandler.js","src/PitchMappers.js","src/Player.js","src/WebAudioSounder.js","src/getAudioContext.js","src/visualCallbackMakers.js"],"names":["AudioChart","[object Object]","options","context","fail","arguments","length","getAudioContext","Error","result","_assignWrapperCallback","dataWrapper","Wrapper","parameter","callback","frequencyPitchMapper","FrequencyPitchMapper","seriesMin","seriesMax","frequencyLow","frequencyHigh","sounder","WebAudioSounder","this","player","Player","duration","chartContainer","KeyboardHandler","playPause","type","GoogleDataWrapper","data","hasOwnProperty","googleVisualCallbackMaker","chart","JSONDataWrapper","HTMLTableDataWrapper","table","htmlTableVisualCallbackMaker","highlightClass","C3DataWrapper","c3VisualCallbackMaker","getNumberOfColumns","results","i","push","getColumnLabel","series","getColumnRange","min","max","index","getValue","getNumberOfRows","json","object","JSON","parse","Math","apply","values","columns","slice","getElementsByTagName","children","headerCells","textContent","dataCells","parseFloat","_seriesFloats","container","setAttribute","addEventListener","keypressHandler","bind","event","preventDefault","key","handleRight","handleLeft","handleSpace","stepBackward","stepForward","PitchMapper","minimumDatum","maximumDatum","datum","minimumFrequency","maximumFrequency","super","dataRange","ratio","pitchMapper","visualCallback","seriesLen","seriesLength","sampling","samplingInfo","interval","sampleOneIn","in","seriesMaxIndex","_state","minInterval","slots","idealInterval","ceil","console","log","floor","sampleOneInFloat","round","sample","_play","_pause","_playLoop","String","playTimes","playCount","startTime","performance","now","start","playIndex","_playOne","intervalID","setInterval","thisPlayTimeStart","frequency","map","seriesValue","clearInterval","stop","sum","reduce","acc","cur","mean","toFixed","skip","delta","oscillator","createOscillator","connect","destination","value","audioContext","window","AudioContext","undefined","webkitAudioContext","_getAudioContext","row","setSelection","column","className","tds","cell","classList","remove","add","select"],"mappings":"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","sourcesContent":["'use strict'\n/** @module */\n/* exported AudioChart */\n/* global getAudioContext FrequencyPitchMapper WebAudioSounder Player KeyboardHandler GoogleDataWrapper googleVisualCallbackMaker JSONDataWrapper HTMLTableDataWrapper htmlTableVisualCallbackMaker C3DataWrapper c3VisualCallbackMaker */\n\n/**\n * Array index number (starts at zero).\n * Used to specify series and row in visual callbacks.\n * @typedef {integer} index\n */\n\n\n/**\n * A function that highlights the current datum visually.\n * Different callbacks must be created for different types of chart.\n * @callback VisualCallback\n * @param {index} series - The column of the cell to highlight\n * @param {index} row - The row of the cell to highlight\n */\n\n/**\n * @typedef {Object} AudioChartOptions\n * @todo move the documentation here? (Downside is that the branching/groups\n *       of different options required for different chart types would be less *       clear.)\n */\n\n/**\n * @typedef {Object} WrapperAndCallbackResults\n * @property {Function} Wrapper - the data wrapper function\n * @property {Object|HTMLTableElement} parameter\n *\tthe rendered chart, or HTML table\n * @property {VisualCallback} callback\n *\tif requested by the user, a callback is created and returned\n */\n\n/** Main object for API consumers */\nclass AudioChart {\n\t/**\n\t * Create an AudioChart object.\n\t * This first checks to see if the Web Audio API is available, and\n\t * throws an {Error} if not.\n\t * @param {options} options - AudioChart options\n\t * @param {AudioContext} context - the window's AudioContext\n\t */\n\tconstructor(options, context) {\n\t\tconst fail = \"Sorry, your browser doesn't support the Web Audio API.\"\n\n\t\tif (arguments.length < 2) {\n\t\t\tcontext = getAudioContext()\n\t\t\tif (context === null) {\n\t\t\t\tthrow Error(fail)\n\t\t\t}\n\t\t}\n\n\t\tconst result = AudioChart._assignWrapperCallback(options)\n\t\tconst dataWrapper = new result.Wrapper(result.parameter)  // TODO would this be neater if it created and returned by the wrapper assignment function?\n\t\tconst callback = result.callback\n\n\t\tconst frequencyPitchMapper = new FrequencyPitchMapper(\n\t\t\tdataWrapper.seriesMin(0),\n\t\t\tdataWrapper.seriesMax(0),\n\t\t\toptions.frequencyLow,\n\t\t\toptions.frequencyHigh)\n\n\t\tconst sounder = new WebAudioSounder(context)\n\n\t\tthis.player = new Player(\n\t\t\toptions.duration,\n\t\t\tdataWrapper,\n\t\t\tfrequencyPitchMapper,\n\t\t\tsounder,\n\t\t\tcallback)\n\n\t\tif (options.chartContainer) {\n\t\t\tnew KeyboardHandler(\n\t\t\t\toptions.chartContainer,\n\t\t\t\tthis.player)\n\t\t}\n\t}\n\n\t/**\n\t * Passes through play/pause commands to the Player\n\t */\n\tplayPause() {\n\t\tthis.player.playPause()\n\t}\n\n\t/**\n\t * Works out which data source wrapper and visual callback (if requested)\n\t * should be used with this chart.\n\t * @param {AudioChartOptions} options - given by the user\n\t * @returns {WrapperAndCallbackResults}\n\t *\t- data wrapper, data wrapper parameter and callback (if applicable)\n\t *\t  for this chart\n\t */\n\tstatic _assignWrapperCallback(options) {\n\t\tconst result = {\n\t\t\t'Wrapper': null,\n\t\t\t'parameter': null,\n\t\t\t'callback': null\n\t\t}\n\n\t\tswitch (options.type) {\n\t\t\tcase 'google':\n\t\t\t\tresult.Wrapper = GoogleDataWrapper\n\t\t\t\tresult.parameter = options.data\n\t\t\t\tif (options.hasOwnProperty('chart')) {\n\t\t\t\t\tresult.callback =\n\t\t\t\t\t\tgoogleVisualCallbackMaker(options.chart)\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\tcase 'json':\n\t\t\t\tresult.Wrapper = JSONDataWrapper\n\t\t\t\tresult.parameter = options.data\n\t\t\t\tbreak\n\t\t\tcase 'htmlTable':\n\t\t\t\tresult.Wrapper = HTMLTableDataWrapper\n\t\t\t\tresult.parameter = options.table\n\t\t\t\tif (options.hasOwnProperty('highlightClass')) {\n\t\t\t\t\tresult.callback = htmlTableVisualCallbackMaker(\n\t\t\t\t\t\toptions.table,\n\t\t\t\t\t\toptions.highlightClass)\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\tcase 'c3':\n\t\t\t\tresult.Wrapper = C3DataWrapper\n\t\t\t\tresult.parameter = options.data\n\t\t\t\tif (options.hasOwnProperty('chart')) {\n\t\t\t\t\tresult.callback =\n\t\t\t\t\t\tc3VisualCallbackMaker(options.chart)\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\tdefault:\n\t\t\t\tthrow Error(\"Invalid data type '\" + options.type + \"' given.\")\n\t\t}\n\n\t\treturn result\n\t}\n}\n","'use strict'\n/**\n * @interface DataWrapper\n *\n * The common interface that the other DataWrappers use.  This is validated\n * by the unit tests.\n *\n * Note: it is not done as a superclass (as {@link PitchMapper} is) because\n *       there's really nothing in common implementation-wise; only the\n *       interface is shared.\n *\n * @private\n */\n/**\n * Returns the number of series in the underlying data\n * @function DataWrapper#numSeries\n * @returns {integer} The number of series\n */\n/**\n * Get a list of the underlying data series names\n * @function DataWrapper#seriesNames\n * @returns {string[]} An array of the series names\n */\n/**\n * What is the minimum value in a given series?\n * @function DataWrapper#seriesMin\n * @param {index} series - The series number\n * @returns {Number} The minimum value in the series\n */\n/**\n * What is the maximum value in a given series?\n * @function DataWrapper#seriesMax\n * @param {index} series - The series number\n * @returns {Number} The maximum value in the series\n */\n/**\n * Get value of specific datum\n * @function DataWrapper#seriesValue\n * @param {index} series - The series number\n * @param {index} index - The row number\n * @todo rename `index` to `row`?\n * @returns {Number} the datum\n */\n/**\n * What is the length of a series?\n * @function DataWrapper#seriesLength\n * @param {index} series - The series\n * @returns {integer} The number of data in the series\n */\n\n\n/**\n * This interfaces to Google's {@link https://developers.google.com/chart/interactive/docs/reference#DataTable|DataTable} class.\n *\n * @private\n * @implements {DataWrapper}\n * @param {GoogleDataTable} data - The in-memory GoogleDataTable\n */\nclass GoogleDataWrapper {\n\tconstructor(data) {\n\t\tthis.data = data\n\t}\n\n\tnumSeries() {\n\t\treturn this.data.getNumberOfColumns() - 1\n\t}\n\n\tseriesNames() {\n\t\tconst results = []\n\t\tfor (let i = 0; i < this.data.getNumberOfColumns() - 1; i++) {\n\t\t\tresults.push(this.data.getColumnLabel(i))\n\t\t}\n\t\treturn results\n\t}\n\n\tseriesMin(series) {\n\t\treturn this.data.getColumnRange(series + 1).min\n\t}\n\n\tseriesMax(series) {\n\t\treturn this.data.getColumnRange(series + 1).max\n\t}\n\n\tseriesValue(series, index) {\n\t\treturn this.data.getValue(index, series + 1)\n\t}\n\n\tseriesLength(series) {\n\t\treturn this.data.getNumberOfRows()\n\t}\n}\n\n\n/**\n * This allows a JSON fragment to be used as a data source.\n *\n * @todo document format\n *\n * @private\n * @implements {DataWrapper}\n * @param {JSON} json - The JSON data, as a string or object\n */\nclass JSONDataWrapper {\n\tconstructor(json) {\n\t\tif (typeof json === 'string') {\n\t\t\tthis.object = JSON.parse(json)\n\t\t} else if (typeof json === 'object') {\n\t\t\tthis.object = json\n\t\t} else {\n\t\t\tthrow Error('Please provide a JSON string or derived object.')\n\t\t}\n\t}\n\n\tnumSeries() {\n\t\treturn this.object.data.length\n\t}\n\n\tseriesNames() {\n\t\tconst results = []\n\t\tfor (let i = 0; i < this.object.data.length; i++) {\n\t\t\tresults.push(this.object.data[i].series)\n\t\t}\n\t\treturn results\n\t}\n\n\tseriesMin(series) {\n\t\treturn Math.min.apply(this, this.object.data[series].values)\n\t}\n\n\tseriesMax(series) {\n\t\treturn Math.max.apply(this, this.object.data[series].values)\n\t}\n\n\tseriesValue(series, index) {\n\t\treturn this.object.data[series].values[index]\n\t}\n\n\tseriesLength(series) {\n\t\treturn this.object.data[series].values.length\n\t}\n}\n\n\n/**\n * Support C3-format data objects\n *\n * @todo document format\n *\n * @private\n * @implements {DataWrapper}\n * @param {Object} data - The C3-format data object\n */\nclass C3DataWrapper {\n\tconstructor(data) {\n\t\tif (typeof data === 'object') {\n\t\t\tthis.object = data\n\t\t} else {\n\t\t\tthrow Error('Please provide a C3-format data object.')\n\t\t}\n\t}\n\n\tnumSeries() {\n\t\treturn this.object.columns.length\n\t}\n\n\tseriesNames() {\n\t\tconst results = []\n\t\tfor (let i = 0; i < this.object.columns.length; i++) {\n\t\t\tresults.push(this.object.columns[i][0])\n\t\t}\n\t\treturn results\n\t}\n\n\tseriesMin(series) {\n\t\treturn Math.min.apply(this, this.object.columns[series].slice(1))\n\t}\n\n\tseriesMax(series) {\n\t\treturn Math.max.apply(this, this.object.columns[series].slice(1))\n\t}\n\n\tseriesValue(series, index) {\n\t\treturn this.object.columns[series][index + 1]\n\t}\n\n\tseriesLength(series) {\n\t\treturn this.object.columns[series].length - 1\n\t}\n}\n\n\n/**\n * Allows an HTML table to be used as a data source.\n *\n * @private\n * @implements {DataWrapper}\n * @param {HTMLTableElement} table - The in-DOM table element\n * @todo check it's a table\n */\nclass HTMLTableDataWrapper {\n\tconstructor(table) {\n\t\tthis.table = table\n\t\tif (!this.table) {\n\t\t\tthrow Error('No table given.')\n\t\t}\n\t}\n\n\tnumSeries() {\n\t\treturn this.table.getElementsByTagName('tr')[0].children.length\n\t}\n\n\tseriesNames() {\n\t\tconst headerCells = this.table.getElementsByTagName('th')\n\t\tconst results = []\n\t\tfor (let i = 0; i < headerCells.length; i++) {\n\t\t\tresults.push(headerCells[i].textContent)\n\t\t}\n\t\treturn results\n\t}\n\n\t_seriesFloats(series) {\n\t\tconst dataCells = this.table.getElementsByTagName('td')\n\t\tconst results = []\n\t\tfor (let i = 0; i < dataCells.length; i++) {\n\t\t\tresults.push(parseFloat(dataCells[i].textContent))\n\t\t}\n\t\treturn results\n\t}\n\n\tseriesMin(series) {\n\t\treturn Math.min.apply(this, this._seriesFloats(series))\n\t}\n\n\tseriesMax(series) {\n\t\treturn Math.max.apply(this, this._seriesFloats(series))\n\t}\n\n\tseriesValue(series, index) {\n\t\treturn parseFloat(this.table.getElementsByTagName('tr')[index + 1].children[series].textContent)\n\t}\n\n\tseriesLength(series) {\n\t\treturn this.table.getElementsByTagName('tr').length - 1\n\t}\n}\n","'use strict'\n/**\n * Set up a keyboard event listener to detect chart navigation keypresses.\n * @private\n * @param {HTMLElement} container\n *\t- The element (usually a <code>&lt;div&gt;</code>) containing the chart\n * @param {Player} player - AudioChart Player object\n * @todo mark up the DIV properly\n * @todo check what sort of element we get given? no; could be button?\n */\nclass KeyboardHandler {\n\tconstructor(container, player) {\n\t\tif (!container) {\n\t\t\tthrow Error('No container given')\n\t\t}\n\t\tif (!player) {\n\t\t\tthrow Error('No Player given')\n\t\t}\n\n\t\tcontainer.setAttribute('tabindex', '0')\n\t\tcontainer.addEventListener('keydown', this.keypressHandler.bind(this))\n\t\tthis.player = player\n\t}\n\n\t/**\n\t * Handle keypresses\n\t *\n\t * Note: This is bound to the {@link KeyboardHandler} so that it can call\n\t *       the right handler methods.\n\t *\n\t * @param {KeyboardEvent} event - the KeyboardEvent that occured\n\t * @todo make link work\n\t */\n\tkeypressHandler(event) {\n\t\tevent.preventDefault()  // TODO should this be here or later? check for defaultPrevented?\n\n\t\tif (event.key === 'ArrowRight') {\n\t\t\tthis.handleRight()\n\t\t} else if (event.key === 'ArrowLeft' ) {\n\t\t\tthis.handleLeft()\n\t\t} else if (event.key === ' ') {\n\t\t\tthis.handleSpace()\n\t\t}\n\t}\n\n\t/** Handle a left arrow being pressed */\n\thandleLeft() {\n\t\tthis.player.stepBackward()\n\t}\n\n\t/** Handle a right arrow being pressed */\n\thandleRight() {\n\t\tthis.player.stepForward()\n\t}\n\n\t/** Handle the space key being pressed */\n\thandleSpace() {\n\t\tthis.player.playPause()\n\t}\n}\n","'use strict'\n/**\n * Base Pitch Mapper\n * @private\n * @abstract\n */\nclass PitchMapper {\n\t/**\n\t * Create a base Pitch Mapper\n\t * @param {number} minimumDatum - the minimum value in this data series\n\t * @param {number} maximumDatum - the maximum value in this data series\n\t */\n\tconstructor(minimumDatum, maximumDatum) {\n\t\tthis.minimumDatum = minimumDatum\n\t\tthis.maximumDatum = maximumDatum\n\t\tif (this.minimumDatum > this.maximumDatum) {\n\t\t\tthrow Error('minimum datum should be <= maximum datum')\n\t\t}\n\t}\n\n\t/**\n\t * Map a datum to an output value\n\t * @param {number} datum - the datum to be mapped\n\t * @abstract\n\t */\n\tmap(datum) {\n\t\tthrow new Error('Base map() must be overriden.')\n\t}\n}\n\n\n/**\n * Maps each datum to a corresponding frequency.\n * @private\n * @extends {PitchMapper}\n */\nclass FrequencyPitchMapper extends PitchMapper {\n\t/**\n\t * Create a Frequency Pitch Mapper\n\t * @param {number} minimumDatum - the minimum value in this data series\n\t * @param {number} maximumDatum - the maximum value in this data series\n\t * @param {number} minimumFrequency - the minimum output frequency\n\t * @param {number} maximumFrequency - the maximum output frequency\n\t */\n\tconstructor(minimumDatum, maximumDatum, minimumFrequency, maximumFrequency) {\n\t\tsuper(minimumDatum, maximumDatum)\n\t\tthis.minimumFrequency = minimumFrequency\n\t\tthis.maximumFrequency = maximumFrequency\n\t\tif (this.minimumFrequency > this.maximumFrequency) {\n\t\t\tthrow Error('minimum frequency must be <= maximum frequency')\n\t\t}\n\t\tthis.dataRange = this.maximumDatum - this.minimumDatum\n\t}\n\n\t/**\n\t * @param {number} datum - the datum to be mapped\n\t * @returns {number} frequency for this datum\n\t */\n\tmap(datum) {\n\t\tlet ratio\n\t\tif (this.dataRange) {\n\t\t\tratio = (datum - this.minimumDatum) / this.dataRange\n\t\t} else {\n\t\t\tratio = 0.5\n\t\t}\n\t\treturn this.minimumFrequency + ratio * (this.maximumFrequency - this.minimumFrequency)\n\t}\n}\n","'use strict'\n/**\n * Orchestrates the audible (and visual cursor) rendering of the chart\n * @private\n * @param {integer} duration - the length of the rendering in milliseconds\n * @param {DataWrapper} data - the underlying data (wrapped in interface)\n * @param {PitchMapper} pitchMapper - maps data to pitches\n * @param {WebAudioSounder} sounder - the sounder object\n * @param {VisualCallback} visualCallback - the callback function that highlights the current datum\n */\nclass Player {\n\tconstructor(duration, data, pitchMapper, sounder, visualCallback) {\n\t\tthis.data = data\n\t\tthis.pitchMapper = pitchMapper\n\t\tthis.sounder = sounder\n\t\tif (arguments.length < 5) {\n\t\t\tthis.visualCallback = null\n\t\t} else {\n\t\t\tthis.visualCallback = visualCallback\n\t\t}\n\n\t\tconst seriesLen = this.data.seriesLength(0)\n\n\t\tconst sampling = Player.samplingInfo(duration, seriesLen)\n\t\tthis.interval = sampling.interval\n\t\tthis.sampleOneIn = sampling.in\n\n\t\tthis.seriesMaxIndex = seriesLen - 1  // TODO just use seriesLen?\n\t\tthis._state = 'ready'\n\t}\n\n\t/* static function to work out sampling rate */\n\tstatic samplingInfo(duration, seriesLen) {\n\t\tconst minInterval = 10\n\t\tlet interval\n\t\tlet sampleOneIn\n\t\tlet slots\n\n\t\tconst idealInterval = Math.ceil(duration / seriesLen)\n\t\tconsole.log(`sampleInfo: duration: ${duration}; series length: ${seriesLen}; ideal interval: ${idealInterval}`)\n\n\t\tif (idealInterval < minInterval) {\n\t\t\tinterval = minInterval\n\t\t\tslots = Math.floor(duration / minInterval)\n\t\t\tconst sampleOneInFloat = seriesLen / slots\n\t\t\tsampleOneIn = Math.round(seriesLen / slots)\n\t\t\tconsole.log(`sampleInfo: Need to sample 1 in ${sampleOneIn} (${sampleOneInFloat})`)\n\t\t} else {\n\t\t\tslots = Math.floor(duration / minInterval)\n\t\t\tinterval = idealInterval\n\t\t\tsampleOneIn = 1\n\t\t}\n\n\t\tconsole.log(`sampleInfo: it will take ${ (seriesLen / sampleOneIn) * interval}`)\n\n\t\treturn {\n\t\t\t'sample': 1,\n\t\t\t'in': sampleOneIn,\n\t\t\t'interval': interval\n\t\t}\n\t}\n\n\t/**\n\t * Main entry point; manages state.\n\t */\n\tplayPause() {\n\t\tswitch (this._state) {\n\t\t\tcase 'ready':\n\t\t\t\tthis._play()\n\t\t\t\tbreak\n\t\t\tcase 'playing':\n\t\t\t\tthis._pause()\n\t\t\t\tbreak\n\t\t\tcase 'paused':\n\t\t\t\tthis._playLoop()\n\t\t\t\tbreak\n\t\t\tcase 'finished':\n\t\t\t\tthis._play()\n\t\t\t\tbreak\n\t\t\tdefault:\n\t\t\t\tthrow Error('Player error: invalid state: ' + String(this._state))\n\t\t}\n\t}\n\n\t/**\n\t * Resets play state and sets up a recurring function to update the sound\n\t * (and, optionally, visual callback) at an interval dependant on the\n\t * number of data.\n\t */\n\t_play() {\n\t\t// Debugging info\n\t\tthis.playTimes = []  // store all lengths of time that playOne took\n\t\tthis.playCount = 0   // how many datum points were actually sounded?\n\n\t\tthis.startTime = performance.now()\n\t\tthis.sounder.start(0)\n\t\tthis.playIndex = 0\n\n\t\tthis._playLoop()\n\t}\n\n\t/**\n\t * Update state and set _playOne() to run regularly, to render the sound\n\t * (and optional visual cursor movement).\n\t */\n\t_playLoop() {\n\t\tthis._state = 'playing'\n\t\tthis._playOne()  // so that it starts immediately\n\t\tthis.intervalID = setInterval(() => this._playOne(), this.interval)\n\t}\n\n\t/**\n\t * This is where the sound is actually played.  If a visual callback was\n\t * specified, this also coordinates the visual highlighting of the current\n\t * datum as the playback occurs.\n\t */\n\t_playOne() {\n\t\tconst thisPlayTimeStart = performance.now()\n\n\t\tif (this.playIndex <= this.seriesMaxIndex) {\n\t\t\tif (this.visualCallback !== null) {\n\t\t\t\tthis.visualCallback(0, this.playIndex)\n\t\t\t}\n\n\t\t\tthis.sounder.frequency(\n\t\t\t\tthis.pitchMapper.map(\n\t\t\t\t\tthis.data.seriesValue(0, this.playIndex)))\n\t\t} else {\n\t\t\tclearInterval(this.intervalID)\n\t\t\tthis.sounder.stop()\n\t\t\tthis._state = 'finished'\n\n\t\t\t// Debugging info\n\t\t\tconsole.log(`Player: Playing ${this.playCount} of ${this.playIndex} took ${Math.round(performance.now() - this.startTime)} ms`)\n\t\t\tconst sum = this.playTimes.reduce((acc, cur) => acc + cur)\n\t\t\tconst mean = sum / this.playTimes.length\n\t\t\tconsole.log(`Player: Average play func time: ${mean.toFixed(2)} ms`)\n\t\t}\n\n\t\tthis.playIndex += this.sampleOneIn > 0 ? this.sampleOneIn : 1  // TODO sl\n\t\tthis.playCount += 1\n\t\tthis.playTimes.push(performance.now() - thisPlayTimeStart)\n\t}\n\n\t/**\n\t * Temporarily pause the rendering of the chart.\n\t * This inherently keeps the sound going at the frequency it was at when\n\t * the pause was triggered.\n\t * @todo feature/object to stop/fade the sound after n seconds?\n\t */\n\t_pause() {\n\t\tclearInterval(this.intervalID)\n\t\tthis._state = 'paused'\n\t}\n\n\tstepBackward(skip) {\n\t\tconst delta = skip || 50\n\t\tthis.playIndex -= delta\n\t\tif (this.playIndex < 0) {\n\t\t\tthis.playIndex = 0  // TODO test limiting\n\t\t}\n\t\tif (this._state === 'paused') {\n\t\t\tthis._playOne()\n\t\t}\n\t}\n\n\tstepForward(skip) {\n\t\tconst delta = skip || 50\n\t\tthis.playIndex += delta\n\t\tif (this.playIndex > this.seriesMaxIndex) {\n\t\t\tthis.playIndex = this.seriesMaxIndex  // TODO test limiting\n\t\t}\n\t\tif (this._state === 'paused') {\n\t\t\tthis._playOne()\n\t\t}\n\t}\n}\n","'use strict'\n/**\n * Outputs sound using the Web Audio API\n * @private\n * @param {AudioContext} context - the Web Audio API context\n */\nclass WebAudioSounder {\n\tconstructor(context) {\n\t\tthis.context = context\n\t}\n\n\t/**\n\t * Start the oscillator\n\t */\n\tstart() {\n\t\t// Oscillators cannot be re-used\n\t\tthis.oscillator = this.context.createOscillator()\n\t\tthis.oscillator.connect(this.context.destination)\n\t\tthis.oscillator.start(0)\n\t}\n\n\t/**\n\t * Set the frequency of the oscillator at a given point in time\n\t * @param {number} frequency - the frequency to change to\n\t */\n\tfrequency(frequency) {\n\t\tthis.oscillator.frequency.value = frequency\n\t}\n\n\t/**\n\t * Stop the oscillator at a given time\n\t */\n\tstop() {\n\t\tthis.oscillator.stop()\n\t}\n}\n","'use strict'\n/**\n * Ensures that there is only one Web Audio context per page.\n * Sets up a new AudioContext the first time it's called; then re-uses it.\n * @private\n * @returns {AudioContext} page-global Web Audio context\n */\nvar getAudioContext = (function() {\n\tlet audioContext = null\n\n\tif (window.AudioContext !== undefined) {\n\t\taudioContext = new window.AudioContext()\n\t} else if (window.webkitAudioContext !== undefined) {\n\t\t/* eslint-disable new-cap */\n\t\taudioContext = new window.webkitAudioContext()\n\t\t/* eslint-enable new-cap */\n\t}\n\n\tfunction _getAudioContext() {\n\t\treturn audioContext\n\t}\n\n\treturn _getAudioContext\n})()\n","'use strict'\n/**\n * Generates a function that moves the cursor on a Google Chart\n * @private\n * @param {GoogleChart} chart - the in-memory GoogleChart object\n * @returns {VisualCallback} the callback\n */\nvar googleVisualCallbackMaker = function(chart) {\n\treturn function(series, row) {\n\t\tchart.setSelection([\n\t\t\t{\n\t\t\t\t'row': row,\n\t\t\t\t'column': series + 1\n\t\t\t}\n\t\t])\n\t}\n}\n\n\n/**\n * Generate a function that can be used to highlight table cells\n * @private\n * @param {HTMLTableElement} table - The in-DOM table element\n * @param {string} className - Name of the CSS highlight class\n * @returns {VisualCallback} The highlighting function\n */\nvar htmlTableVisualCallbackMaker = function(table, className) {\n\treturn function(series, row) {\n\t\tconst tds = table.getElementsByTagName('td')\n\t\tlet cell  // TODO remove\n\t\tfor (let i = 0; i < tds.length; i++) {\n\t\t\tcell = tds[i]\n\t\t\tcell.classList.remove(className)\n\t\t}\n\t\tcell = table.getElementsByTagName('td')[row]\n\t\tcell.classList.add(className)\n\t}\n}\n\n\n/**\n * Generates a function that moves the cursor on a C3 Chart\n * @private\n * @param {Object} chart - the in-memory C3 chart object\n * @returns {VisualCallback} the callback\n * @todo define C3 chart type?\n */\nvar c3VisualCallbackMaker = function(chart) {\n\treturn function(series, row) {\n\t\tchart.select(null, [row], true)\n\t}\n}\n"]}