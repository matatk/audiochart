{"version":3,"sources":["src/audiochart-all.js"],"names":["exports","GoogleDataWrapper","[object Object]","data","this","getNumberOfColumns","results","i","push","getColumnLabel","series","getColumnRange","min","max","index","getValue","getNumberOfRows","JSONDataWrapper","json","object","JSON","parse","Error","length","Math","apply","values","C3DataWrapper","columns","slice","HTMLTableDataWrapper","table","getElementsByTagName","children","headerCells","textContent","dataCells","parseFloat","_seriesFloats","PitchMapper","minimumDatum","maximumDatum","datum","FrequencyPitchMapper","minimumFrequency","maximumFrequency","super","dataRange","ratio","WebAudioSounder","context","oscillator","createOscillator","connect","destination","start","frequency","value","stop","Player","duration","pitchMapper","sounder","visualCallback","arguments","seriesLen","seriesLength","sampling","samplingInfo","interval","sampleOneIn","in","seriesMaxIndex","_state","slots","idealInterval","ceil","console","log","sampleOneInFloat","floor","round","sample","_play","_pause","_playLoop","String","playTimes","playCount","startTime","performance","now","playIndex","_playOne","intervalID","setInterval","thisPlayTimeStart","map","seriesValue","clearInterval","mean","reduce","acc","cur","toFixed","skip","delta","getAudioContext","audioContext","undefined","window","AudioContext","webkitAudioContext","googleVisualCallbackMaker","chart","row","setSelection","column","htmlTableVisualCallbackMaker","className","tds","cell","classList","remove","add","c3VisualCallbackMaker","select","KeyboardHandler","container","player","setAttribute","addEventListener","keypressHandler","bind","event","preventDefault","key","handleRight","handleLeft","handleSpace","stepBackward","stepForward","playPause","AudioChart","options","result","_assignWrapperCallback","dataWrapper","Wrapper","parameter","callback","frequencyPitchMapper","seriesMin","seriesMax","frequencyLow","frequencyHigh","chartContainer","type","hasOwnProperty","highlightClass"],"mappings":"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","sourcesContent":["'use strict';\n(function(exports) {\n\t/**\n\t * @interface DataWrapper\n\t *\n\t * The common interface that the other DataWrappers use.  This is validated\n\t * by the unit tests.\n\t *\n\t * Note: it is not done as a superclass (as {@link PitchMapper} is) because\n\t *       there's really nothing in common implementation-wise; only the\n\t *       interface is shared.\n\t *\n\t * @private\n\t */\n\t/**\n\t * Returns the number of series in the underlying data\n\t * @function DataWrapper#numSeries\n\t * @returns {integer} The number of series\n\t */\n\t/**\n\t * Get a list of the underlying data series names\n\t * @function DataWrapper#seriesNames\n\t * @returns {string[]} An array of the series names\n\t */\n\t/**\n\t * What is the minimum value in a given series?\n\t * @function DataWrapper#seriesMin\n\t * @param {index} series - The series number\n\t * @returns {Number} The minimum value in the series\n\t */\n\t/**\n\t * What is the maximum value in a given series?\n\t * @function DataWrapper#seriesMax\n\t * @param {index} series - The series number\n\t * @returns {Number} The maximum value in the series\n\t */\n\t/**\n\t * Get value of specific datum\n\t * @function DataWrapper#seriesValue\n\t * @param {index} series - The series number\n\t * @param {index} index - The row number\n\t * @todo rename `index` to `row`?\n\t * @returns {Number} the datum\n\t */\n\t/**\n\t * What is the length of a series?\n\t * @function DataWrapper#seriesLength\n\t * @param {index} series - The series\n\t * @returns {integer} The number of data in the series\n\t */\n\n\n\t/**\n\t * This interfaces to Google's {@link https://developers.google.com/chart/interactive/docs/reference#DataTable|DataTable} class.\n\t *\n\t * @private\n\t * @implements {DataWrapper}\n\t * @param {GoogleDataTable} data - The in-memory GoogleDataTable\n\t */\n\tclass GoogleDataWrapper {\n\t\tconstructor(data) {\n\t\t\tthis.data = data\n\t\t}\n\n\t\tnumSeries() {\n\t\t\treturn this.data.getNumberOfColumns() - 1\n\t\t}\n\n\t\tseriesNames() {\n\t\t\tconst results = []\n\t\t\tfor (let i = 0; i < this.data.getNumberOfColumns() - 1; i++) {\n\t\t\t\tresults.push(this.data.getColumnLabel(i))\n\t\t\t}\n\t\t\treturn results\n\t\t}\n\n\t\tseriesMin(series) {\n\t\t\treturn this.data.getColumnRange(series + 1).min\n\t\t}\n\n\t\tseriesMax(series) {\n\t\t\treturn this.data.getColumnRange(series + 1).max\n\t\t}\n\n\t\tseriesValue(series, index) {\n\t\t\treturn this.data.getValue(index, series + 1)\n\t\t}\n\n\t\tseriesLength(series) {\n\t\t\treturn this.data.getNumberOfRows()\n\t\t}\n\t}\n\n\n\t/**\n\t * This allows a JSON fragment to be used as a data source.\n\t *\n\t * @todo document format\n\t *\n\t * @private\n\t * @implements {DataWrapper}\n\t * @param {JSON} json - The JSON data, as a string or object\n\t */\n\tclass JSONDataWrapper {\n\t\tconstructor(json) {\n\t\t\tif (typeof json === 'string') {\n\t\t\t\tthis.object = JSON.parse(json)\n\t\t\t} else if (typeof json === 'object') {\n\t\t\t\tthis.object = json\n\t\t\t} else {\n\t\t\t\tthrow Error('Please provide a JSON string or derived object.')\n\t\t\t}\n\t\t}\n\n\t\tnumSeries() {\n\t\t\treturn this.object.data.length\n\t\t}\n\n\t\tseriesNames() {\n\t\t\tconst results = []\n\t\t\tfor (let i = 0; i < this.object.data.length; i++) {\n\t\t\t\tresults.push(this.object.data[i].series)\n\t\t\t}\n\t\t\treturn results\n\t\t}\n\n\t\tseriesMin(series) {\n\t\t\treturn Math.min.apply(this, this.object.data[series].values)\n\t\t}\n\n\t\tseriesMax(series) {\n\t\t\treturn Math.max.apply(this, this.object.data[series].values)\n\t\t}\n\n\t\tseriesValue(series, index) {\n\t\t\treturn this.object.data[series].values[index]\n\t\t}\n\n\t\tseriesLength(series) {\n\t\t\treturn this.object.data[series].values.length\n\t\t}\n\t}\n\n\n\t/**\n\t * Support C3-format data objects\n\t *\n\t * @todo document format\n\t *\n\t * @private\n\t * @implements {DataWrapper}\n\t * @param {Object} data - The C3-format data object\n\t */\n\tclass C3DataWrapper {\n\t\tconstructor(data) {\n\t\t\tif (typeof data === 'object') {\n\t\t\t\tthis.object = data\n\t\t\t} else {\n\t\t\t\tthrow Error('Please provide a C3-format data object.')\n\t\t\t}\n\t\t}\n\n\t\tnumSeries() {\n\t\t\treturn this.object.columns.length\n\t\t}\n\n\t\tseriesNames() {\n\t\t\tconst results = []\n\t\t\tfor (let i = 0; i < this.object.columns.length; i++) {\n\t\t\t\tresults.push(this.object.columns[i][0])\n\t\t\t}\n\t\t\treturn results\n\t\t}\n\n\t\tseriesMin(series) {\n\t\t\treturn Math.min.apply(this, this.object.columns[series].slice(1))\n\t\t}\n\n\t\tseriesMax(series) {\n\t\t\treturn Math.max.apply(this, this.object.columns[series].slice(1))\n\t\t}\n\n\t\tseriesValue(series, index) {\n\t\t\treturn this.object.columns[series][index + 1]\n\t\t}\n\n\t\tseriesLength(series) {\n\t\t\treturn this.object.columns[series].length - 1\n\t\t}\n\t}\n\n\n\t/**\n\t * Allows an HTML table to be used as a data source.\n\t *\n\t * @private\n\t * @implements {DataWrapper}\n\t * @param {HTMLTableElement} table - The in-DOM table element\n\t * @todo check it's a table\n\t */\n\tclass HTMLTableDataWrapper {\n\t\tconstructor(table) {\n\t\t\tthis.table = table\n\t\t\tif (!this.table) {\n\t\t\t\tthrow Error('No table given.')\n\t\t\t}\n\t\t}\n\n\t\tnumSeries() {\n\t\t\treturn this.table.getElementsByTagName('tr')[0].children.length\n\t\t}\n\n\t\tseriesNames() {\n\t\t\tconst headerCells = this.table.getElementsByTagName('th')\n\t\t\tconst results = []\n\t\t\tfor (let i = 0; i < headerCells.length; i++) {\n\t\t\t\tresults.push(headerCells[i].textContent)\n\t\t\t}\n\t\t\treturn results\n\t\t}\n\n\t\t_seriesFloats(series) {\n\t\t\tconst dataCells = this.table.getElementsByTagName('td')\n\t\t\tconst results = []\n\t\t\tfor (let i = 0; i < dataCells.length; i++) {\n\t\t\t\tresults.push(parseFloat(dataCells[i].textContent))\n\t\t\t}\n\t\t\treturn results\n\t\t}\n\n\t\tseriesMin(series) {\n\t\t\treturn Math.min.apply(this, this._seriesFloats(series))\n\t\t}\n\n\t\tseriesMax(series) {\n\t\t\treturn Math.max.apply(this, this._seriesFloats(series))\n\t\t}\n\n\t\tseriesValue(series, index) {\n\t\t\treturn parseFloat(this.table.getElementsByTagName('tr')[index + 1].children[series].textContent)\n\t\t}\n\n\t\tseriesLength(series) {\n\t\t\treturn this.table.getElementsByTagName('tr').length - 1\n\t\t}\n\t}\n\n\t/**\n\t * Base Pitch Mapper\n\t * @private\n\t * @abstract\n\t */\n\tclass PitchMapper {\n\t\t/**\n\t\t * Create a base Pitch Mapper\n\t\t * @param {number} minimumDatum - the minimum value in this data series\n\t\t * @param {number} maximumDatum - the maximum value in this data series\n\t\t */\n\t\tconstructor(minimumDatum, maximumDatum) {\n\t\t\tthis.minimumDatum = minimumDatum\n\t\t\tthis.maximumDatum = maximumDatum\n\t\t\tif (this.minimumDatum > this.maximumDatum) {\n\t\t\t\tthrow Error('minimum datum should be <= maximum datum')\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Map a datum to an output value\n\t\t * @param {number} datum - the datum to be mapped\n\t\t * @abstract\n\t\t */\n\t\tmap(datum) {\n\t\t\tthrow new Error('Base map() must be overriden.')\n\t\t}\n\t}\n\n\n\t/**\n\t * Maps each datum to a corresponding frequency.\n\t * @private\n\t * @extends {PitchMapper}\n\t */\n\tclass FrequencyPitchMapper extends PitchMapper {\n\t\t/**\n\t\t * Create a Frequency Pitch Mapper\n\t\t * @param {number} minimumDatum - the minimum value in this data series\n\t\t * @param {number} maximumDatum - the maximum value in this data series\n\t\t * @param {number} minimumFrequency - the minimum output frequency\n\t\t * @param {number} maximumFrequency - the maximum output frequency\n\t\t */\n\t\tconstructor(minimumDatum, maximumDatum, minimumFrequency, maximumFrequency) {\n\t\t\tsuper(minimumDatum, maximumDatum)\n\t\t\tthis.minimumFrequency = minimumFrequency\n\t\t\tthis.maximumFrequency = maximumFrequency\n\t\t\tif (this.minimumFrequency > this.maximumFrequency) {\n\t\t\t\tthrow Error('minimum frequency must be <= maximum frequency')\n\t\t\t}\n\t\t\tthis.dataRange = this.maximumDatum - this.minimumDatum\n\t\t}\n\n\t\t/**\n\t\t * @param {number} datum - the datum to be mapped\n\t\t * @returns {number} frequency for this datum\n\t\t */\n\t\tmap(datum) {\n\t\t\tlet ratio\n\t\t\tif (this.dataRange) {\n\t\t\t\tratio = (datum - this.minimumDatum) / this.dataRange\n\t\t\t} else {\n\t\t\t\tratio = 0.5\n\t\t\t}\n\t\t\treturn this.minimumFrequency + ratio * (this.maximumFrequency - this.minimumFrequency)\n\t\t}\n\t}\n\n\t/**\n\t * Outputs sound using the Web Audio API\n\t * @private\n\t * @param {AudioContext} context - the Web Audio API context\n\t */\n\tclass WebAudioSounder {\n\t\tconstructor(context) {\n\t\t\tthis.context = context\n\t\t}\n\n\t\t/**\n\t\t * Start the oscillator\n\t\t */\n\t\tstart() {\n\t\t\t// Oscillators cannot be re-used\n\t\t\tthis.oscillator = this.context.createOscillator()\n\t\t\tthis.oscillator.connect(this.context.destination)\n\t\t\tthis.oscillator.start(0)\n\t\t}\n\n\t\t/**\n\t\t * Set the frequency of the oscillator at a given point in time\n\t\t * @param {number} frequency - the frequency to change to\n\t\t */\n\t\tfrequency(frequency) {\n\t\t\tthis.oscillator.frequency.value = frequency\n\t\t}\n\n\t\t/**\n\t\t * Stop the oscillator at a given time\n\t\t */\n\t\tstop() {\n\t\t\tthis.oscillator.stop()\n\t\t}\n\t}\n\n\t/**\n\t * Orchestrates the audible (and visual cursor) rendering of the chart\n\t * @private\n\t * @param {integer} duration - the length of the rendering in milliseconds\n\t * @param {DataWrapper} data - the underlying data (wrapped in interface)\n\t * @param {PitchMapper} pitchMapper - maps data to pitches\n\t * @param {WebAudioSounder} sounder - the sounder object\n\t * @param {VisualCallback} visualCallback - the callback function that highlights the current datum\n\t */\n\tclass Player {\n\t\tconstructor(duration, data, pitchMapper, sounder, visualCallback) {\n\t\t\tthis.data = data\n\t\t\tthis.pitchMapper = pitchMapper\n\t\t\tthis.sounder = sounder\n\t\t\tif (arguments.length < 5) {\n\t\t\t\tthis.visualCallback = null\n\t\t\t} else {\n\t\t\t\tthis.visualCallback = visualCallback\n\t\t\t}\n\n\t\t\tconst seriesLen = this.data.seriesLength(0)\n\n\t\t\tconst sampling = Player.samplingInfo(duration, seriesLen)\n\t\t\tthis.interval = sampling.interval\n\t\t\tthis.sampleOneIn = sampling.in\n\n\t\t\tthis.seriesMaxIndex = seriesLen - 1  // TODO just use seriesLen?\n\t\t\tthis._state = 'ready'\n\t\t}\n\n\t\t/* static function to work out sampling rate */\n\t\tstatic samplingInfo(duration, seriesLen) {\n\t\t\tconst minInterval = 10\n\t\t\tlet interval\n\t\t\tlet sampleOneIn\n\t\t\tlet slots\n\n\t\t\tconst idealInterval = Math.ceil(duration / seriesLen)\n\t\t\tconsole.log(`sampleInfo: duration: ${duration}; series length: ${seriesLen}; ideal interval: ${idealInterval}`)\n\n\t\t\tif (idealInterval < minInterval) {\n\t\t\t\tinterval = minInterval\n\t\t\t\tslots = Math.floor(duration / minInterval)\n\t\t\t\tconst sampleOneInFloat = seriesLen / slots\n\t\t\t\tsampleOneIn = Math.round(seriesLen / slots)\n\t\t\t\tconsole.log(`sampleInfo: Need to sample 1 in ${sampleOneIn} (${sampleOneInFloat})`)\n\t\t\t} else {\n\t\t\t\tslots = Math.floor(duration / minInterval)\n\t\t\t\tinterval = idealInterval\n\t\t\t\tsampleOneIn = 1\n\t\t\t}\n\n\t\t\tconsole.log(`sampleInfo: it will take ${ (seriesLen / sampleOneIn) * interval}`)\n\n\t\t\treturn {\n\t\t\t\t'sample': 1,\n\t\t\t\t'in': sampleOneIn,\n\t\t\t\t'interval': interval\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Main entry point; manages state.\n\t\t */\n\t\tplayPause() {\n\t\t\tswitch (this._state) {\n\t\t\t\tcase 'ready':\n\t\t\t\t\tthis._play()\n\t\t\t\t\tbreak\n\t\t\t\tcase 'playing':\n\t\t\t\t\tthis._pause()\n\t\t\t\t\tbreak\n\t\t\t\tcase 'paused':\n\t\t\t\t\tthis._playLoop()\n\t\t\t\t\tbreak\n\t\t\t\tcase 'finished':\n\t\t\t\t\tthis._play()\n\t\t\t\t\tbreak\n\t\t\t\tdefault:\n\t\t\t\t\tthrow Error('Player error: invalid state: ' + String(this._state))\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Resets play state and sets up a recurring function to update the sound\n\t\t * (and, optionally, visual callback) at an interval dependant on the\n\t\t * number of data.\n\t\t */\n\t\t_play() {\n\t\t\t// Debugging info\n\t\t\tthis.playTimes = []  // store all lengths of time that playOne took\n\t\t\tthis.playCount = 0   // how many datum points were actually sounded?\n\n\t\t\tthis.startTime = performance.now()\n\t\t\tthis.sounder.start(0)\n\t\t\tthis.playIndex = 0\n\n\t\t\tthis._playLoop()\n\t\t}\n\n\t\t/**\n\t\t * Update state and set _playOne() to run regularly, to render the sound\n\t\t * (and optional visual cursor movement).\n\t\t */\n\t\t_playLoop() {\n\t\t\tthis._state = 'playing'\n\t\t\tthis._playOne()  // so that it starts immediately\n\t\t\tthis.intervalID = setInterval(() => this._playOne(), this.interval)\n\t\t}\n\n\t\t/**\n\t\t * This is where the sound is actually played.  If a visual callback was\n\t\t * specified, this also coordinates the visual highlighting of the current\n\t\t * datum as the playback occurs.\n\t\t */\n\t\t_playOne() {\n\t\t\tconst thisPlayTimeStart = performance.now()\n\n\t\t\tif (this.playIndex <= this.seriesMaxIndex) {\n\t\t\t\tif (this.visualCallback !== null) {\n\t\t\t\t\tthis.visualCallback(0, this.playIndex)\n\t\t\t\t}\n\n\t\t\t\tthis.sounder.frequency(\n\t\t\t\t\tthis.pitchMapper.map(\n\t\t\t\t\t\tthis.data.seriesValue(0, this.playIndex)))\n\t\t\t} else {\n\t\t\t\tclearInterval(this.intervalID)\n\t\t\t\tthis.sounder.stop()\n\t\t\t\tthis._state = 'finished'\n\n\t\t\t\t// Debugging info\n\t\t\t\tconsole.log(`Player: Playing ${this.playCount} of ${this.playIndex} took ${Math.round(performance.now() - this.startTime)} ms`)\n\t\t\t\tconst sum = this.playTimes.reduce((acc, cur) => acc + cur)\n\t\t\t\tconst mean = sum / this.playTimes.length\n\t\t\t\tconsole.log(`Player: Average play func time: ${mean.toFixed(2)} ms`)\n\t\t\t}\n\n\t\t\tthis.playIndex += this.sampleOneIn > 0 ? this.sampleOneIn : 1  // TODO sl\n\t\t\tthis.playCount += 1\n\t\t\tthis.playTimes.push(performance.now() - thisPlayTimeStart)\n\t\t}\n\n\t\t/**\n\t\t * Temporarily pause the rendering of the chart.\n\t\t * This inherently keeps the sound going at the frequency it was at when\n\t\t * the pause was triggered.\n\t\t * @todo feature/object to stop/fade the sound after n seconds?\n\t\t */\n\t\t_pause() {\n\t\t\tclearInterval(this.intervalID)\n\t\t\tthis._state = 'paused'\n\t\t}\n\n\t\tstepBackward(skip) {\n\t\t\tconst delta = skip || 50\n\t\t\tthis.playIndex -= delta\n\t\t\tif (this.playIndex < 0) {\n\t\t\t\tthis.playIndex = 0  // TODO test limiting\n\t\t\t}\n\t\t\tif (this._state === 'paused') {\n\t\t\t\tthis._playOne()\n\t\t\t}\n\t\t}\n\n\t\tstepForward(skip) {\n\t\t\tconst delta = skip || 50\n\t\t\tthis.playIndex += delta\n\t\t\tif (this.playIndex > this.seriesMaxIndex) {\n\t\t\t\tthis.playIndex = this.seriesMaxIndex  // TODO test limiting\n\t\t\t}\n\t\t\tif (this._state === 'paused') {\n\t\t\t\tthis._playOne()\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Ensures that there is only one Web Audio context per page.\n\t * Sets up a new AudioContext the first time it's called; then re-uses it.\n\t * @private\n\t * @returns {AudioContext} page-global Web Audio context\n\t */\n\tvar getAudioContext = (function() {\n\t\tlet audioContext = null\n\n\t\tif (window.AudioContext !== undefined) {\n\t\t\taudioContext = new window.AudioContext()\n\t\t} else if (window.webkitAudioContext !== undefined) {\n\t\t\t/* eslint-disable new-cap */\n\t\t\taudioContext = new window.webkitAudioContext()\n\t\t\t/* eslint-enable new-cap */\n\t\t}\n\n\t\tfunction _getAudioContext() {\n\t\t\treturn audioContext\n\t\t}\n\n\t\treturn _getAudioContext\n\t})()\n\n\t/**\n\t * Generates a function that moves the cursor on a Google Chart\n\t * @private\n\t * @param {GoogleChart} chart - the in-memory GoogleChart object\n\t * @returns {VisualCallback} the callback\n\t */\n\tvar googleVisualCallbackMaker = function(chart) {\n\t\treturn function(series, row) {\n\t\t\tchart.setSelection([\n\t\t\t\t{\n\t\t\t\t\t'row': row,\n\t\t\t\t\t'column': series + 1\n\t\t\t\t}\n\t\t\t])\n\t\t}\n\t}\n\n\n\t/**\n\t * Generate a function that can be used to highlight table cells\n\t * @private\n\t * @param {HTMLTableElement} table - The in-DOM table element\n\t * @param {string} className - Name of the CSS highlight class\n\t * @returns {VisualCallback} The highlighting function\n\t */\n\tvar htmlTableVisualCallbackMaker = function(table, className) {\n\t\treturn function(series, row) {\n\t\t\tconst tds = table.getElementsByTagName('td')\n\t\t\tlet cell  // TODO remove\n\t\t\tfor (let i = 0; i < tds.length; i++) {\n\t\t\t\tcell = tds[i]\n\t\t\t\tcell.classList.remove(className)\n\t\t\t}\n\t\t\tcell = table.getElementsByTagName('td')[row]\n\t\t\tcell.classList.add(className)\n\t\t}\n\t}\n\n\n\t/**\n\t * Generates a function that moves the cursor on a C3 Chart\n\t * @private\n\t * @param {Object} chart - the in-memory C3 chart object\n\t * @returns {VisualCallback} the callback\n\t * @todo define C3 chart type?\n\t */\n\tvar c3VisualCallbackMaker = function(chart) {\n\t\treturn function(series, row) {\n\t\t\tchart.select(null, [row], true)\n\t\t}\n\t}\n\n\t/**\n\t * Set up a keyboard event listener to detect chart navigation keypresses.\n\t * @private\n\t * @param {HTMLElement} container\n\t *\t- The element (usually a <code>&lt;div&gt;</code>) containing the chart\n\t * @param {Player} player - AudioChart Player object\n\t * @todo mark up the DIV properly\n\t * @todo check what sort of element we get given? no; could be button?\n\t */\n\tclass KeyboardHandler {\n\t\tconstructor(container, player) {\n\t\t\tif (!container) {\n\t\t\t\tthrow Error('No container given')\n\t\t\t}\n\t\t\tif (!player) {\n\t\t\t\tthrow Error('No Player given')\n\t\t\t}\n\n\t\t\tcontainer.setAttribute('tabindex', '0')\n\t\t\tcontainer.addEventListener('keydown', this.keypressHandler.bind(this))\n\t\t\tthis.player = player\n\t\t}\n\n\t\t/**\n\t\t * Handle keypresses\n\t\t *\n\t\t * Note: This is bound to the {@link KeyboardHandler} so that it can call\n\t\t *       the right handler methods.\n\t\t *\n\t\t * @param {KeyboardEvent} event - the KeyboardEvent that occured\n\t\t * @todo make link work\n\t\t */\n\t\tkeypressHandler(event) {\n\t\t\tevent.preventDefault()  // TODO should this be here or later? check for defaultPrevented?\n\n\t\t\tif (event.key === 'ArrowRight') {\n\t\t\t\tthis.handleRight()\n\t\t\t} else if (event.key === 'ArrowLeft' ) {\n\t\t\t\tthis.handleLeft()\n\t\t\t} else if (event.key === ' ') {\n\t\t\t\tthis.handleSpace()\n\t\t\t}\n\t\t}\n\n\t\t/** Handle a left arrow being pressed */\n\t\thandleLeft() {\n\t\t\tthis.player.stepBackward()\n\t\t}\n\n\t\t/** Handle a right arrow being pressed */\n\t\thandleRight() {\n\t\t\tthis.player.stepForward()\n\t\t}\n\n\t\t/** Handle the space key being pressed */\n\t\thandleSpace() {\n\t\t\tthis.player.playPause()\n\t\t}\n\t}\n\n\t/** @module */\n\t/* exported AudioChart */\n\t/* global getAudioContext FrequencyPitchMapper WebAudioSounder Player KeyboardHandler GoogleDataWrapper googleVisualCallbackMaker JSONDataWrapper HTMLTableDataWrapper htmlTableVisualCallbackMaker C3DataWrapper c3VisualCallbackMaker */\n\n\t/**\n\t * Array index number (starts at zero).\n\t * Used to specify series and row in visual callbacks.\n\t * @typedef {integer} index\n\t */\n\n\n\t/**\n\t * A function that highlights the current datum visually.\n\t * Different callbacks must be created for different types of chart.\n\t * @callback VisualCallback\n\t * @param {index} series - The column of the cell to highlight\n\t * @param {index} row - The row of the cell to highlight\n\t */\n\n\t/**\n\t * @typedef {Object} AudioChartOptions\n\t * @todo move the documentation here? (Downside is that the branching/groups\n\t *       of different options required for different chart types would be less *       clear.)\n\t */\n\n\t/**\n\t * @typedef {Object} WrapperAndCallbackResults\n\t * @property {Function} Wrapper - the data wrapper function\n\t * @property {Object|HTMLTableElement} parameter\n\t *\tthe rendered chart, or HTML table\n\t * @property {VisualCallback} callback\n\t *\tif requested by the user, a callback is created and returned\n\t */\n\n\t/** Main object for API consumers */\n\tclass AudioChart {\n\t\t/**\n\t\t * Create an AudioChart object.\n\t\t * This first checks to see if the Web Audio API is available, and\n\t\t * throws an {Error} if not.\n\t\t * @param {options} options - AudioChart options\n\t\t * @param {AudioContext} context - the window's AudioContext\n\t\t */\n\t\tconstructor(options, context) {\n\t\t\tconst fail = \"Sorry, your browser doesn't support the Web Audio API.\"\n\n\t\t\tif (arguments.length < 2) {\n\t\t\t\tcontext = getAudioContext()\n\t\t\t\tif (context === null) {\n\t\t\t\t\tthrow Error(fail)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst result = AudioChart._assignWrapperCallback(options)\n\t\t\tconst dataWrapper = new result.Wrapper(result.parameter)  // TODO would this be neater if it created and returned by the wrapper assignment function?\n\t\t\tconst callback = result.callback\n\n\t\t\tconst frequencyPitchMapper = new FrequencyPitchMapper(\n\t\t\t\tdataWrapper.seriesMin(0),\n\t\t\t\tdataWrapper.seriesMax(0),\n\t\t\t\toptions.frequencyLow,\n\t\t\t\toptions.frequencyHigh)\n\n\t\t\tconst sounder = new WebAudioSounder(context)\n\n\t\t\tthis.player = new Player(\n\t\t\t\toptions.duration,\n\t\t\t\tdataWrapper,\n\t\t\t\tfrequencyPitchMapper,\n\t\t\t\tsounder,\n\t\t\t\tcallback)\n\n\t\t\tif (options.chartContainer) {\n\t\t\t\tnew KeyboardHandler(\n\t\t\t\t\toptions.chartContainer,\n\t\t\t\t\tthis.player)\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Passes through play/pause commands to the Player\n\t\t */\n\t\tplayPause() {\n\t\t\tthis.player.playPause()\n\t\t}\n\n\t\t/**\n\t\t * Works out which data source wrapper and visual callback (if requested)\n\t\t * should be used with this chart.\n\t\t * @param {AudioChartOptions} options - given by the user\n\t\t * @returns {WrapperAndCallbackResults}\n\t\t *\t- data wrapper, data wrapper parameter and callback (if applicable)\n\t\t *\t  for this chart\n\t\t * @private\n\t\t */\n\t\tstatic _assignWrapperCallback(options) {\n\t\t\tconst result = {\n\t\t\t\t'Wrapper': null,\n\t\t\t\t'parameter': null,\n\t\t\t\t'callback': null\n\t\t\t}\n\n\t\t\tswitch (options.type) {\n\t\t\t\tcase 'google':\n\t\t\t\t\tresult.Wrapper = GoogleDataWrapper\n\t\t\t\t\tresult.parameter = options.data\n\t\t\t\t\tif (options.hasOwnProperty('chart')) {\n\t\t\t\t\t\tresult.callback =\n\t\t\t\t\t\t\tgoogleVisualCallbackMaker(options.chart)\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\tcase 'json':\n\t\t\t\t\tresult.Wrapper = JSONDataWrapper\n\t\t\t\t\tresult.parameter = options.data\n\t\t\t\t\tbreak\n\t\t\t\tcase 'htmlTable':\n\t\t\t\t\tresult.Wrapper = HTMLTableDataWrapper\n\t\t\t\t\tresult.parameter = options.table\n\t\t\t\t\tif (options.hasOwnProperty('highlightClass')) {\n\t\t\t\t\t\tresult.callback = htmlTableVisualCallbackMaker(\n\t\t\t\t\t\t\toptions.table,\n\t\t\t\t\t\t\toptions.highlightClass)\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\tcase 'c3':\n\t\t\t\t\tresult.Wrapper = C3DataWrapper\n\t\t\t\t\tresult.parameter = options.data\n\t\t\t\t\tif (options.hasOwnProperty('chart')) {\n\t\t\t\t\t\tresult.callback =\n\t\t\t\t\t\t\tc3VisualCallbackMaker(options.chart)\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\tdefault:\n\t\t\t\t\tthrow Error(\"Invalid data type '\" + options.type + \"' given.\")\n\t\t\t}\n\n\t\t\treturn result\n\t\t}\n\t}\n\n\texports.AudioChart = AudioChart\n})(this)\n"]}